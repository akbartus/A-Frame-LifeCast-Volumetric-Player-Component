/*
The MIT License

Copyright © 2021-2024 Lifecast Incorporated

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/


/*
The MIT License

Copyright © 2021 Lifecast Incorporated

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

//////////////////////////////////////
// 7. Icons.js //
/////////////////////////////////////
let play_buttonSrc = "data:image/png;base64,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dTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAAsTAAALEwEAmpwYAAAE9GlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDIgNzkuZGJhM2RhM2I1LCAyMDIzLzEyLzE1LTEwOjQyOjM3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjUuNyAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjQtMDQtMjlUMTQ6MTI6MDUtMDc6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDI0LTA1LTA5VDEzOjM5OjQ0LTA3OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDI0LTA1LTA5VDEzOjM5OjQ0LTA3OjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpjZjJkZjg3NC00YjlkLTQzMzgtODIwMi1jMzRkNTZmM2MzODEiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6Y2Yy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";

let pause_buttonSrc = "data:image/png;base64,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dTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAAsTAAALEwEAmpwYAAAE9GlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDIgNzkuZGJhM2RhM2I1LCAyMDIzLzEyLzE1LTEwOjQyOjM3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjUuNyAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjQtMDQtMjlUMTQ6MTI6MDUtMDc6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDI0LTA1LTA5VDEzOjM5OjU4LTA3OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDI0LTA1LTA5VDEzOjM5OjU4LTA3OjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozNjEyMmU5OC0xMmYwLTQxMjYtOTUyNy05NDM5ZmNiOTUxOTAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MzYx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";

let rewind_buttonSrc = "data:image/png;base64,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dTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAAsTAAALEwEAmpwYAAAE9GlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDIgNzkuZGJhM2RhM2I1LCAyMDIzLzEyLzE1LTEwOjQyOjM3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjUuNyAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjQtMDQtMjlUMTQ6MTI6MDUtMDc6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDI0LTA1LTA5VDEzOjM5OjUxLTA3OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDI0LTA1LTA5VDEzOjM5OjUxLTA3OjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowOTFiMjhiMC05MmUyLTQ5MjYtYjcwOC04ZjA3ODZhYWFhOWQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MDkx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";

let spinner = "data:image/png;base64,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dTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAAsTAAALEwEAmpwYAAAE9GlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDIgNzkuZGJhM2RhM2I1LCAyMDIzLzEyLzE1LTEwOjQyOjM3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjUuNyAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjQtMDQtMjlUMTQ6MTI6MDUtMDc6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDI0LTA1LTA5VDEzOjQwOjA1LTA3OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDI0LTA1LTA5VDEzOjQwOjA1LTA3OjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoyMTk4OTRmZS1mZmNmLTRkMWItOGEzNy1iNTMzNDZjMDY3ZTkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MjE5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";



//////////////////////////////////////
// 1. Lifecast Video Player Shaders //
//////////////////////////////////////
const VR180_VertexShader = `
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;

const VR180_FragmentShader = `
precision highp float;

#include <common>
uniform sampler2D uTexture;
varying vec2 vUv;

void main() {
  vec2 texture_uv = vec2(vUv.s, vUv.t);
  gl_FragColor = texture2D(uTexture, texture_uv);
}
`;

const decode12bit = `
float decodeInverseDepth(vec2 depth_uv_unscaled, vec2 cell_offset) {
#if defined(DECODE_12BIT)

  vec2 depth_uv_lo = cell_offset + (depth_uv_unscaled + vec2(0.0, 1.0)) * 0.33333333 * 0.5;
  vec2 depth_uv_hi = cell_offset + (depth_uv_unscaled + vec2(1.0, 1.0)) * 0.33333333 * 0.5;

  // Sampling the texture with interpolation causes errors when reconstructing bits,
  // so we'll use texelFetch instead
  //float ds_lo = texture2D(uTexture, depth_uv_lo).r;
  //float ds_hi = texture2D(uTexture, depth_uv_hi).r;

  ivec2 texture_size = textureSize(uTexture, 0);
  ivec2 texel_coord_lo = ivec2(vec2(texture_size) * depth_uv_lo);
  ivec2 texel_coord_hi = ivec2(vec2(texture_size) * depth_uv_hi);
  float ds_lo = texelFetch(uTexture, texel_coord_lo, 0).r;
  float ds_hi = texelFetch(uTexture, texel_coord_hi, 0).r;

  int lo = int(ds_lo * 255.0) & 255;
  int hi = int(ds_hi * 255.0) & 255;
  hi = hi / 16; // decode error correcting code
  lo = (hi & 1) == 0 ? lo : 255 - lo; // unfold

  int i12 = (lo & 255) | ((hi & 15) << 8);
  float f12 = float(i12) / float((1 << 12) - 1);

  return clamp(f12, 0.0001, 1.0);

#else

  // Classic: interpolated texture2D
  //vec2 depth_uv_8bit = cell_offset + depth_uv_unscaled * 0.33333;
  //float depth_sample_8bit = clamp(texture2D(uTexture, depth_uv_8bit).r, 0.0001, 1.0);
  //return depth_sample_8bit;

  // New (maybe faster): texelFetch
  vec2 depth_uv_8bit = cell_offset + depth_uv_unscaled * 0.33333;
  ivec2 texture_size = textureSize(uTexture, 0);
  ivec2 texel_coord = ivec2(vec2(texture_size) * depth_uv_8bit);
  float v = texelFetch(uTexture, texel_coord, 0).r;
  return clamp(v, 0.0001, 1.0);

#endif
}
`;

//////////////////////////// LDI3 shaders ////////////////////////////////////////////////

const LDI3_fthetaFgVertexShader = `
precision highp float;

uniform sampler2D uTexture;
varying vec2 vUv;
varying float vS;
`
+ decode12bit +
`
void main() {
  vUv = uv;
#if defined(LAYER2)
  float depth_sample = decodeInverseDepth(vUv, vec2(0.33333333, 0.66666666));
#else
  float depth_sample = decodeInverseDepth(vUv, vec2(0.33333333, 0.33333333));
#endif

  float s = clamp(0.3 / depth_sample, 0.01, 50.0);
  vS = s;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz * s, 1.0);
}
`;

const LDI3_fthetaFgFragmentShader = `
precision highp float;

#include <common>
uniform sampler2D uTexture;
uniform float uEffectRadius;

varying vec2 vUv;
varying float vS;

void main() {
#if defined(LAYER2)
  vec2 alpha_uv   = vec2(vUv.s * 0.33333 + 0.66666, vUv.t * 0.33333 + 0.66666);
  vec2 depth_uv   = vec2(vUv.s * 0.33333 + 0.33333, vUv.t * 0.33333 + 0.66666);
  vec2 texture_uv = vec2(vUv.s * 0.33333,           vUv.t * 0.33333 + 0.66666);
#else
  vec2 alpha_uv   = vec2(vUv.s * 0.33333 + 0.66666, vUv.t * 0.33333 + 0.33333);
  vec2 depth_uv   = vec2(vUv.s * 0.33333 + 0.33333, vUv.t * 0.33333 + 0.33333);
  vec2 texture_uv = vec2(vUv.s * 0.33333,           vUv.t * 0.33333 + 0.33333);
#endif

  vec3 rgb = texture2D(uTexture, texture_uv).rgb;
  float a = texture2D(uTexture, alpha_uv).r;

  // Transition effect
  float q = smoothstep(uEffectRadius - 0.02, uEffectRadius + 0.02, vS);
  rgb = mix(rgb, vec3(0.6, 0.5, 1.0), q);
  a *= smoothstep(uEffectRadius + 0.05, uEffectRadius, vS);

  if (a < 0.02) discard;

  gl_FragColor = vec4(rgb, a);
}
`;

const LDI3_fthetaBgVertexShader = `
precision highp float;
uniform sampler2D uTexture;
`
+ decode12bit +
`
varying vec2 vUv;
varying float vS;

void main() {
  vUv = uv;

  float depth_sample = decodeInverseDepth(vUv, vec2(0.33333333, 0.0));
  float s = clamp(0.3 / depth_sample, 0.01, 50.0);
  vS = s;

  gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz * s, 1.0);
}
`;

const LDI3_fthetaBgFragmentShader = `
precision highp float;

#include <common>
uniform sampler2D uTexture;
uniform float uEffectRadius;
varying vec2 vUv;
varying float vS;

void main() {
  vec2 texture_uv = vec2(vUv.s * 0.33333, vUv.t * 0.33333);
  vec2 alpha_uv   = vec2(vUv.s * 0.33333 + 0.66666, vUv.t * 0.33333);
  float a = texture2D(uTexture, alpha_uv).r;
  vec3 rgb = texture2D(uTexture, texture_uv).rgb;

  // Transition effect
  float q = smoothstep(uEffectRadius - 0.02, uEffectRadius + 0.02, vS);
  rgb = mix(rgb, vec3(0.6, 0.5, 1.0), q);
  a *= smoothstep(uEffectRadius + 0.05, uEffectRadius, vS);

  if (a < 0.02) discard;
  gl_FragColor = vec4(rgb, a);
}
`;


//////////////////////////////////////
// 3. Ldi3Mesh //
//////////////////////////////////////
const NUM_LAYERS = 3;

/*
 That class is a THREE Object3D displaying a LDI.
 */
class Ldi3Mesh extends THREE.Object3D {
    layer_to_meshes = Array.from({ length: NUM_LAYERS }, () => []);

    ftheta_scale = null

    constructor(_decode_12bit, texture, _ftheta_scale = null) {

        super()
        this.ftheta_scale = 1.15;
        console.log("_ftheta_scale=", this.ftheta_scale);

        // Make the initial shader uniforms.
        this.uniforms = {
            uTexture: { value: texture },
            uEffectRadius: { value: 100.0 },  // Set to a lower value to play intro animation
        };

        // Make the foreground mesh material.
        var shader_prefix = "";
        if (_decode_12bit) shader_prefix += "#define DECODE_12BIT\n";

        //// LDI3 materials ////

        const ldi3_layer0_material = this.ldi3_layer0_material = new THREE.ShaderMaterial({
            vertexShader:   shader_prefix + LDI3_fthetaBgVertexShader,
            fragmentShader: shader_prefix + LDI3_fthetaBgFragmentShader,
            uniforms: this.uniforms,
            depthTest: true,
            depthWrite: true,
            transparent: true,
            wireframe: false
        });
        ldi3_layer0_material.side = THREE.BackSide;
        ldi3_layer0_material.depthFunc = THREE.LessDepth;

        const ldi3_layer1_material = this.ldi3_layer1_material = new THREE.ShaderMaterial({
            vertexShader:   shader_prefix + LDI3_fthetaFgVertexShader,
            fragmentShader: shader_prefix + LDI3_fthetaFgFragmentShader,
            uniforms: this.uniforms,
            depthTest: true,
            depthWrite: true,
            transparent: true,
            wireframe: false
        });
        ldi3_layer1_material.side = THREE.BackSide;
        ldi3_layer1_material.depthFunc = THREE.LessEqualDepth;

        const ldi3_layer2_material = this.ldi3_layer2_material = new THREE.ShaderMaterial({
            vertexShader:    "#define LAYER2\n" + shader_prefix + LDI3_fthetaFgVertexShader,
            fragmentShader:  "#define LAYER2\n" + shader_prefix + LDI3_fthetaFgFragmentShader,
            uniforms: this.uniforms,
            depthTest: true,
            depthWrite: true,
            transparent: true,
            wireframe: false
        });
        ldi3_layer2_material.side = THREE.BackSide;
        ldi3_layer2_material.depthFunc = THREE.LessEqualDepth;

        const inflation = 3.0;
        this.makeEquiangularMesh(ldi3_layer0_material, 128, 4, 0, inflation);
        this.makeEquiangularMesh(ldi3_layer1_material, 128, 4, 1, inflation);
        this.makeEquiangularMesh(ldi3_layer2_material, 96, 4, 2, inflation); // HACK: a few less triangles here to give some overhead on Quest Pro to not exceed triangle limit when displaying extra UI elements.
    }

    makeEquiangularMesh(material, GRID_SIZE, NUM_PATCHES, order, ftheta_inflation, is_oculus) {
        const NUM_QUADS_PER_SIDE = NUM_PATCHES * GRID_SIZE;
        const MARGIN = 2;

        for (var patch_j = 0; patch_j < NUM_PATCHES; ++patch_j) {
            for (var patch_i = 0; patch_i < NUM_PATCHES; ++patch_i) {
                const verts   = [];
                const indices = [];
                const uvs     = [];

                for (var j = 0; j <= GRID_SIZE; ++j) {
                    for (var i = 0; i <= GRID_SIZE; ++i) {
                        const ii = i + patch_i * GRID_SIZE;
                        const jj = j + patch_j * GRID_SIZE;
                        const u  = ii / NUM_QUADS_PER_SIDE;
                        const v  = jj / NUM_QUADS_PER_SIDE;

                        const a = 2.0 * (u - 0.5);
                        const b = 2.0 * (v - 0.5);
                        const theta = Math.atan2(b, a);
                        var r = Math.sqrt(a * a + b * b) / this.ftheta_scale;
                        r = 0.5 * r + 0.5 * Math.pow(r, ftheta_inflation);
                        const phi = r * Math.PI / 2.0;

                        const x = Math.cos(theta) * Math.sin(phi);
                        const y = Math.sin(theta) * Math.sin(phi);
                        const z = -Math.cos(phi);

                        verts.push(x, y, z);
                        uvs.push(u, v);
                    }
                }

                for (var j = 0; j < GRID_SIZE; ++j) {
                    for (var i = 0; i < GRID_SIZE; ++i) {
                        // Skip quads outside the image circle.
                        const ii = i + patch_i * GRID_SIZE;
                        const jj = j + patch_j * GRID_SIZE;
                        const di = ii - NUM_QUADS_PER_SIDE / 2;
                        const dj = jj - NUM_QUADS_PER_SIDE / 2;
                        if (di * di + dj * dj > (NUM_QUADS_PER_SIDE+MARGIN) * (NUM_QUADS_PER_SIDE+MARGIN) / 4) continue;

                        const a = i + (GRID_SIZE + 1) * j;
                        const b = a + 1;
                        const c = a + (GRID_SIZE + 1);
                        const d = c + 1;
                        indices.push(a, c, b);
                        indices.push(c, d, b);
                    }
                }

                if (indices.length > 0) {
                    const geometry = new THREE.BufferGeometry();
                    geometry.setIndex(indices);
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
                    geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));

                    const mesh = new THREE.Mesh(geometry, material);

                    this.layer_to_meshes[order].push(mesh);

                    mesh.frustumCulled = false;

                    mesh.renderOrder = order;
                    this.add(mesh);
                }
            }
        }

    }
}


//////////////////////////////////////
// 4. Vr180Mesh  //
//////////////////////////////////////
class Vr180Mesh extends THREE.Object3D {
    constructor(texture) {
        super();

        this.uniforms = {
            uTexture: { value: texture },
            uEffectRadius: { value: 0 },
        };

        const material = new THREE.ShaderMaterial({
            vertexShader: VR180_VertexShader,
            fragmentShader: VR180_FragmentShader,
            uniforms: this.uniforms,
            side: THREE.DoubleSide,
            transparent: false
        });

        // Create left eye mesh
        const leftMesh = this.createVr180Mesh(material, true);
        leftMesh.layers.set(1);  // Use layer 1 for left eye
        this.add(leftMesh);

        // Create right eye mesh
        const rightMesh = this.createVr180Mesh(material, false);
        rightMesh.layers.set(2);  // Use layer 2 for right eye
        this.add(rightMesh);
    }

    createVr180Mesh(material, isLeftEye) {
        // A half-sphere from angle 180 to 360 degrees, 1000 meter radius
        const geometry = new THREE.SphereGeometry(100, 64, 64, Math.PI, Math.PI);

        // Modify UVs for stereo view
        const uvs = geometry.attributes.uv.array;
        for (let i = 0; i < uvs.length; i += 2) {
            if (isLeftEye) {
                uvs[i] = (1.0 - uvs[i]) * 0.5;  // Left eye
            } else {
                uvs[i] = 1.0 - (uvs[i] * 0.5);  // Right eye
            }
        }

        geometry.attributes.uv.needsUpdate = true;

        return new THREE.Mesh(geometry, material);
    }
}

// //////////////////////////////////////
// // 5. OrbitControls  //
// //////////////////////////////////////

// /*
// The MIT License
// Copyright © 2010-2021 three.js authors
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// */

// // OrbitControls performs orbiting, dollying (zooming), and panning.
// // Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
// //
// //    Orbit - left mouse / touch: one-finger move
// //    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
// //    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

// const _changeEvent = { type: 'change' };
// const _startEvent = { type: 'start' };
// const _endEvent = { type: 'end' };
// const _ray = new THREE.Ray();
// const _plane = new THREE.Plane();
// const TILT_LIMIT = Math.cos( 70 * THREE.MathUtils.DEG2RAD );

// class OrbitControls extends THREE.EventDispatcher {

// 	constructor( object, domElement ) {

// 		super();

// 		this.object = object;
// 		this.domElement = domElement;
// 		this.domElement.style.touchAction = 'none'; // disable touch scroll

// 		// Set to false to disable this control
// 		this.enabled = true;

// 		// "target" sets the location of focus, where the object orbits around
// 		this.target = new THREE.Vector3();

// 		// Sets the 3D cursor (similar to Blender), from which the maxTargetRadius takes effect
// 		this.cursor = new THREE.Vector3();

// 		// How far you can dolly in and out ( PerspectiveCamera only )
// 		this.minDistance = 0;
// 		this.maxDistance = Infinity;

// 		// How far you can zoom in and out ( OrthographicCamera only )
// 		this.minZoom = 0;
// 		this.maxZoom = Infinity;

// 		// Limit camera target within a spherical area around the cursor
// 		this.minTargetRadius = 0;
// 		this.maxTargetRadius = Infinity;

// 		// How far you can orbit vertically, upper and lower limits.
// 		// Range is 0 to Math.PI radians.
// 		this.minPolarAngle = 0; // radians
// 		this.maxPolarAngle = Math.PI; // radians

// 		// How far you can orbit horizontally, upper and lower limits.
// 		// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
// 		this.minAzimuthAngle = - Infinity; // radians
// 		this.maxAzimuthAngle = Infinity; // radians

// 		// Set to true to enable damping (inertia)
// 		// If damping is enabled, you must call controls.update() in your animation loop
// 		this.enableDamping = false;
// 		this.dampingFactor = 0.05;

// 		// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
// 		// Set to false to disable zooming
// 		this.enableZoom = true;
// 		this.zoomSpeed = 1.0;

// 		// Set to false to disable rotating
// 		this.enableRotate = true;
// 		this.rotateSpeed = 1.0;

// 		// Set to false to disable panning
// 		this.enablePan = true;
// 		this.panSpeed = 1.0;
// 		this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
// 		this.keyPanSpeed = 7.0;	// pixels moved per arrow key push
// 		this.zoomToCursor = false;

// 		// Set to true to automatically rotate around the target
// 		// If auto-rotate is enabled, you must call controls.update() in your animation loop
// 		this.autoRotate = false;
// 		this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60

// 		// The four arrow keys
// 		this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };

// 		// Mouse buttons
// 		this.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };

// 		// Touch fingers
// 		this.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };

// 		// for reset
// 		this.target0 = this.target.clone();
// 		this.position0 = this.object.position.clone();
// 		this.zoom0 = this.object.zoom;

// 		// the target DOM element for key events
// 		this._domElementKeyEvents = null;

// 		//
// 		// public methods
// 		//

// 		this.getPolarAngle = function () {

// 			return spherical.phi;

// 		};

// 		this.getAzimuthalAngle = function () {

// 			return spherical.theta;

// 		};

// 		this.getDistance = function () {

// 			return this.object.position.distanceTo( this.target );

// 		};

// 		this.listenToKeyEvents = function ( domElement ) {

// 			domElement.addEventListener( 'keydown', onKeyDown );
// 			this._domElementKeyEvents = domElement;

// 		};

// 		this.stopListenToKeyEvents = function () {

// 			this._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );
// 			this._domElementKeyEvents = null;

// 		};

// 		this.saveState = function () {

// 			scope.target0.copy( scope.target );
// 			scope.position0.copy( scope.object.position );
// 			scope.zoom0 = scope.object.zoom;

// 		};

// 		this.reset = function () {

// 			scope.target.copy( scope.target0 );
// 			scope.object.position.copy( scope.position0 );
// 			scope.object.zoom = scope.zoom0;

// 			scope.object.updateProjectionMatrix();
// 			scope.dispatchEvent( _changeEvent );

// 			scope.update();

// 			state = STATE.NONE;

// 		};

// 		// this method is exposed, but perhaps it would be better if we can make it private...
// 		this.update = function () {

// 			const offset = new THREE.Vector3();

// 			// so camera.up is the orbit axis
// 			const quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
// 			const quatInverse = quat.clone().invert();

// 			const lastPosition = new THREE.Vector3();
// 			const lastQuaternion = new THREE.Quaternion();
// 			const lastTargetPosition = new THREE.Vector3();

// 			const twoPI = 2 * Math.PI;

// 			return function update( deltaTime = null ) {

// 				const position = scope.object.position;

// 				offset.copy( position ).sub( scope.target );

// 				// rotate offset to "y-axis-is-up" space
// 				offset.applyQuaternion( quat );

// 				// angle from z-axis around y-axis
// 				spherical.setFromVector3( offset );

// 				if ( scope.autoRotate && state === STATE.NONE ) {

// 					rotateLeft( getAutoRotationAngle( deltaTime ) );

// 				}

// 				if ( scope.enableDamping ) {

// 					spherical.theta += sphericalDelta.theta * scope.dampingFactor;
// 					spherical.phi += sphericalDelta.phi * scope.dampingFactor;

// 				} else {

// 					spherical.theta += sphericalDelta.theta;
// 					spherical.phi += sphericalDelta.phi;

// 				}

// 				// restrict theta to be between desired limits

// 				let min = scope.minAzimuthAngle;
// 				let max = scope.maxAzimuthAngle;

// 				if ( isFinite( min ) && isFinite( max ) ) {

// 					if ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;

// 					if ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;

// 					if ( min <= max ) {

// 						spherical.theta = Math.max( min, Math.min( max, spherical.theta ) );

// 					} else {

// 						spherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?
// 							Math.max( min, spherical.theta ) :
// 							Math.min( max, spherical.theta );

// 					}

// 				}

// 				// restrict phi to be between desired limits
// 				spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

// 				spherical.makeSafe();


// 				// move target to panned location

// 				if ( scope.enableDamping === true ) {

// 					scope.target.addScaledVector( panOffset, scope.dampingFactor );

// 				} else {

// 					scope.target.add( panOffset );

// 				}

// 				// Limit the target distance from the cursor to create a sphere around the center of interest
// 				scope.target.sub( scope.cursor );
// 				scope.target.clampLength( scope.minTargetRadius, scope.maxTargetRadius );
// 				scope.target.add( scope.cursor );

// 				let zoomChanged = false;
// 				// adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera
// 				// we adjust zoom later in these cases
// 				if ( scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera ) {

// 					spherical.radius = clampDistance( spherical.radius );

// 				} else {

// 					const prevRadius = spherical.radius;
// 					spherical.radius = clampDistance( spherical.radius * scale );
// 					zoomChanged = prevRadius != spherical.radius;

// 				}

// 				offset.setFromSpherical( spherical );

// 				// rotate offset back to "camera-up-vector-is-up" space
// 				offset.applyQuaternion( quatInverse );

// 				position.copy( scope.target ).add( offset );

// 				scope.object.lookAt( scope.target );

// 				if ( scope.enableDamping === true ) {

// 					sphericalDelta.theta *= ( 1 - scope.dampingFactor );
// 					sphericalDelta.phi *= ( 1 - scope.dampingFactor );

// 					panOffset.multiplyScalar( 1 - scope.dampingFactor );

// 				} else {

// 					sphericalDelta.set( 0, 0, 0 );

// 					panOffset.set( 0, 0, 0 );

// 				}

// 				// adjust camera position
// 				if ( scope.zoomToCursor && performCursorZoom ) {

// 					let newRadius = null;
// 					if ( scope.object.isPerspectiveCamera ) {

// 						// move the camera down the pointer ray
// 						// this method avoids floating point error
// 						const prevRadius = offset.length();
// 						newRadius = clampDistance( prevRadius * scale );

// 						const radiusDelta = prevRadius - newRadius;
// 						scope.object.position.addScaledVector( dollyDirection, radiusDelta );
// 						scope.object.updateMatrixWorld();

// 						zoomChanged = !! radiusDelta;

// 					} else if ( scope.object.isOrthographicCamera ) {

// 						// adjust the ortho camera position based on zoom changes
// 						const mouseBefore = new THREE.Vector3( mouse.x, mouse.y, 0 );
// 						mouseBefore.unproject( scope.object );

// 						const prevZoom = scope.object.zoom;
// 						scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );
// 						scope.object.updateProjectionMatrix();

// 						zoomChanged = prevZoom !== scope.object.zoom;

// 						const mouseAfter = new THREE.Vector3( mouse.x, mouse.y, 0 );
// 						mouseAfter.unproject( scope.object );

// 						scope.object.position.sub( mouseAfter ).add( mouseBefore );
// 						scope.object.updateMatrixWorld();

// 						newRadius = offset.length();

// 					} else {

// 						console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.' );
// 						scope.zoomToCursor = false;

// 					}

// 					// handle the placement of the target
// 					if ( newRadius !== null ) {

// 						if ( this.screenSpacePanning ) {

// 							// position the orbit target in front of the new camera position
// 							scope.target.set( 0, 0, - 1 )
// 								.transformDirection( scope.object.matrix )
// 								.multiplyScalar( newRadius )
// 								.add( scope.object.position );

// 						} else {

// 							// get the ray and translation plane to compute target
// 							_ray.origin.copy( scope.object.position );
// 							_ray.direction.set( 0, 0, - 1 ).transformDirection( scope.object.matrix );

// 							// if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid
// 							// extremely large values
// 							if ( Math.abs( scope.object.up.dot( _ray.direction ) ) < TILT_LIMIT ) {

// 								object.lookAt( scope.target );

// 							} else {

// 								_plane.setFromNormalAndCoplanarPoint( scope.object.up, scope.target );
// 								_ray.intersectPlane( _plane, scope.target );

// 							}

// 						}

// 					}

// 				} else if ( scope.object.isOrthographicCamera ) {

// 					const prevZoom = scope.object.zoom;
// 					scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );

// 					if ( prevZoom !== scope.object.zoom ) {

// 						scope.object.updateProjectionMatrix();
// 						zoomChanged = true;

// 					}

// 				}

// 				scale = 1;
// 				performCursorZoom = false;

// 				// update condition is:
// 				// min(camera displacement, camera rotation in radians)^2 > EPS
// 				// using small-angle approximation cos(x/2) = 1 - x^2 / 8

// 				if ( zoomChanged ||
// 					lastPosition.distanceToSquared( scope.object.position ) > EPS ||
// 					8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ||
// 					lastTargetPosition.distanceToSquared( scope.target ) > EPS ) {

// 					scope.dispatchEvent( _changeEvent );

// 					lastPosition.copy( scope.object.position );
// 					lastQuaternion.copy( scope.object.quaternion );
// 					lastTargetPosition.copy( scope.target );

// 					return true;

// 				}

// 				return false;

// 			};

// 		}();

// 		this.dispose = function () {

// 			scope.domElement.removeEventListener( 'contextmenu', onContextMenu );

// 			scope.domElement.removeEventListener( 'pointerdown', onPointerDown );
// 			scope.domElement.removeEventListener( 'pointercancel', onPointerUp );
// 			scope.domElement.removeEventListener( 'wheel', onMouseWheel );

// 			scope.domElement.removeEventListener( 'pointermove', onPointerMove );
// 			scope.domElement.removeEventListener( 'pointerup', onPointerUp );

// 			const document = scope.domElement.getRootNode(); // offscreen canvas compatibility

// 			document.removeEventListener( 'keydown', interceptControlDown, { capture: true } );

// 			if ( scope._domElementKeyEvents !== null ) {

// 				scope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );
// 				scope._domElementKeyEvents = null;

// 			}

// 			//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

// 		};

// 		//
// 		// internals
// 		//

// 		const scope = this;

// 		const STATE = {
// 			NONE: - 1,
// 			ROTATE: 0,
// 			DOLLY: 1,
// 			PAN: 2,
// 			TOUCH_ROTATE: 3,
// 			TOUCH_PAN: 4,
// 			TOUCH_DOLLY_PAN: 5,
// 			TOUCH_DOLLY_ROTATE: 6
// 		};

// 		let state = STATE.NONE;

// 		const EPS = 0.000001;

// 		// current position in spherical coordinates
// 		const spherical = new THREE.Spherical ();
// 		const sphericalDelta = new THREE.Spherical ();

// 		let scale = 1;
// 		const panOffset = new THREE.Vector3();

// 		const rotateStart = new THREE.Vector2();
// 		const rotateEnd = new THREE.Vector2();
// 		const rotateDelta = new THREE.Vector2();

// 		const panStart = new THREE.Vector2();
// 		const panEnd = new THREE.Vector2();
// 		const panDelta = new THREE.Vector2();

// 		const dollyStart = new THREE.Vector2();
// 		const dollyEnd = new THREE.Vector2();
// 		const dollyDelta = new THREE.Vector2();

// 		const dollyDirection = new THREE.Vector3();
// 		const mouse = new THREE.Vector2();
// 		let performCursorZoom = false;

// 		const pointers = [];
// 		const pointerPositions = {};

// 		let controlActive = false;

// 		function getAutoRotationAngle( deltaTime ) {

// 			if ( deltaTime !== null ) {

// 				return ( 2 * Math.PI / 60 * scope.autoRotateSpeed ) * deltaTime;

// 			} else {

// 				return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

// 			}

// 		}

// 		function getZoomScale( delta ) {

// 			const normalizedDelta = Math.abs( delta * 0.01 );
// 			return Math.pow( 0.95, scope.zoomSpeed * normalizedDelta );

// 		}

// 		function rotateLeft( angle ) {

// 			sphericalDelta.theta -= angle;

// 		}

// 		function rotateUp( angle ) {

// 			sphericalDelta.phi -= angle;

// 		}

// 		const panLeft = function () {

// 			const v = new THREE.Vector3();

// 			return function panLeft( distance, objectMatrix ) {

// 				v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
// 				v.multiplyScalar( - distance );

// 				panOffset.add( v );

// 			};

// 		}();

// 		const panUp = function () {

// 			const v = new THREE.Vector3();

// 			return function panUp( distance, objectMatrix ) {

// 				if ( scope.screenSpacePanning === true ) {

// 					v.setFromMatrixColumn( objectMatrix, 1 );

// 				} else {

// 					v.setFromMatrixColumn( objectMatrix, 0 );
// 					v.crossVectors( scope.object.up, v );

// 				}

// 				v.multiplyScalar( distance );

// 				panOffset.add( v );

// 			};

// 		}();

// 		// deltaX and deltaY are in pixels; right and down are positive
// 		const pan = function () {

// 			const offset = new THREE.Vector3();

// 			return function pan( deltaX, deltaY ) {

// 				const element = scope.domElement;

// 				if ( scope.object.isPerspectiveCamera ) {

// 					// perspective
// 					const position = scope.object.position;
// 					offset.copy( position ).sub( scope.target );
// 					let targetDistance = offset.length();

// 					// half of the fov is center to top of screen
// 					targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

// 					// we use only clientHeight here so aspect ratio does not distort speed
// 					panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
// 					panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

// 				} else if ( scope.object.isOrthographicCamera ) {

// 					// orthographic
// 					panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
// 					panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

// 				} else {

// 					// camera neither orthographic nor perspective
// 					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
// 					scope.enablePan = false;

// 				}

// 			};

// 		}();

// 		function dollyOut( dollyScale ) {

// 			if ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {

// 				scale /= dollyScale;

// 			} else {

// 				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
// 				scope.enableZoom = false;

// 			}

// 		}

// 		function dollyIn( dollyScale ) {

// 			if ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {

// 				scale *= dollyScale;

// 			} else {

// 				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
// 				scope.enableZoom = false;

// 			}

// 		}

// 		function updateZoomParameters( x, y ) {

// 			if ( ! scope.zoomToCursor ) {

// 				return;

// 			}

// 			performCursorZoom = true;

// 			const rect = scope.domElement.getBoundingClientRect();
// 			const dx = x - rect.left;
// 			const dy = y - rect.top;
// 			const w = rect.width;
// 			const h = rect.height;

// 			mouse.x = ( dx / w ) * 2 - 1;
// 			mouse.y = - ( dy / h ) * 2 + 1;

// 			dollyDirection.set( mouse.x, mouse.y, 1 ).unproject( scope.object ).sub( scope.object.position ).normalize();

// 		}

// 		function clampDistance( dist ) {

// 			return Math.max( scope.minDistance, Math.min( scope.maxDistance, dist ) );

// 		}

// 		//
// 		// event callbacks - update the object state
// 		//

// 		function handleMouseDownRotate( event ) {

// 			rotateStart.set( event.clientX, event.clientY );

// 		}

// 		function handleMouseDownDolly( event ) {

// 			updateZoomParameters( event.clientX, event.clientX );
// 			dollyStart.set( event.clientX, event.clientY );

// 		}

// 		function handleMouseDownPan( event ) {

// 			panStart.set( event.clientX, event.clientY );

// 		}

// 		function handleMouseMoveRotate( event ) {

// 			rotateEnd.set( event.clientX, event.clientY );

// 			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

// 			const element = scope.domElement;

// 			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

// 			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

// 			rotateStart.copy( rotateEnd );

// 			scope.update();

// 		}

// 		function handleMouseMoveDolly( event ) {

// 			dollyEnd.set( event.clientX, event.clientY );

// 			dollyDelta.subVectors( dollyEnd, dollyStart );

// 			if ( dollyDelta.y > 0 ) {

// 				dollyOut( getZoomScale( dollyDelta.y ) );

// 			} else if ( dollyDelta.y < 0 ) {

// 				dollyIn( getZoomScale( dollyDelta.y ) );

// 			}

// 			dollyStart.copy( dollyEnd );

// 			scope.update();

// 		}

// 		function handleMouseMovePan( event ) {

// 			panEnd.set( event.clientX, event.clientY );

// 			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

// 			pan( panDelta.x, panDelta.y );

// 			panStart.copy( panEnd );

// 			scope.update();

// 		}

// 		function handleMouseWheel( event ) {

// 			updateZoomParameters( event.clientX, event.clientY );

// 			if ( event.deltaY < 0 ) {

// 				dollyIn( getZoomScale( event.deltaY ) );

// 			} else if ( event.deltaY > 0 ) {

// 				dollyOut( getZoomScale( event.deltaY ) );

// 			}

// 			scope.update();

// 		}

// 		function handleKeyDown( event ) {

// 			let needsUpdate = false;

// 			switch ( event.code ) {

// 				case scope.keys.UP:

// 					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

// 						rotateUp( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

// 					} else {

// 						pan( 0, scope.keyPanSpeed );

// 					}

// 					needsUpdate = true;
// 					break;

// 				case scope.keys.BOTTOM:

// 					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

// 						rotateUp( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

// 					} else {

// 						pan( 0, - scope.keyPanSpeed );

// 					}

// 					needsUpdate = true;
// 					break;

// 				case scope.keys.LEFT:

// 					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

// 						rotateLeft( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

// 					} else {

// 						pan( scope.keyPanSpeed, 0 );

// 					}

// 					needsUpdate = true;
// 					break;

// 				case scope.keys.RIGHT:

// 					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

// 						rotateLeft( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

// 					} else {

// 						pan( - scope.keyPanSpeed, 0 );

// 					}

// 					needsUpdate = true;
// 					break;

// 			}

// 			if ( needsUpdate ) {

// 				// prevent the browser from scrolling on cursor keys
// 				event.preventDefault();

// 				scope.update();

// 			}


// 		}

// 		function handleTouchStartRotate( event ) {

// 			if ( pointers.length === 1 ) {

// 				rotateStart.set( event.pageX, event.pageY );

// 			} else {

// 				const position = getSecondPointerPosition( event );

// 				const x = 0.5 * ( event.pageX + position.x );
// 				const y = 0.5 * ( event.pageY + position.y );

// 				rotateStart.set( x, y );

// 			}

// 		}

// 		function handleTouchStartPan( event ) {

// 			if ( pointers.length === 1 ) {

// 				panStart.set( event.pageX, event.pageY );

// 			} else {

// 				const position = getSecondPointerPosition( event );

// 				const x = 0.5 * ( event.pageX + position.x );
// 				const y = 0.5 * ( event.pageY + position.y );

// 				panStart.set( x, y );

// 			}

// 		}

// 		function handleTouchStartDolly( event ) {

// 			const position = getSecondPointerPosition( event );

// 			const dx = event.pageX - position.x;
// 			const dy = event.pageY - position.y;

// 			const distance = Math.sqrt( dx * dx + dy * dy );

// 			dollyStart.set( 0, distance );

// 		}

// 		function handleTouchStartDollyPan( event ) {

// 			if ( scope.enableZoom ) handleTouchStartDolly( event );

// 			if ( scope.enablePan ) handleTouchStartPan( event );

// 		}

// 		function handleTouchStartDollyRotate( event ) {

// 			if ( scope.enableZoom ) handleTouchStartDolly( event );

// 			if ( scope.enableRotate ) handleTouchStartRotate( event );

// 		}

// 		function handleTouchMoveRotate( event ) {

// 			if ( pointers.length == 1 ) {

// 				rotateEnd.set( event.pageX, event.pageY );

// 			} else {

// 				const position = getSecondPointerPosition( event );

// 				const x = 0.5 * ( event.pageX + position.x );
// 				const y = 0.5 * ( event.pageY + position.y );

// 				rotateEnd.set( x, y );

// 			}

// 			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

// 			const element = scope.domElement;

// 			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

// 			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

// 			rotateStart.copy( rotateEnd );

// 		}

// 		function handleTouchMovePan( event ) {

// 			if ( pointers.length === 1 ) {

// 				panEnd.set( event.pageX, event.pageY );

// 			} else {

// 				const position = getSecondPointerPosition( event );

// 				const x = 0.5 * ( event.pageX + position.x );
// 				const y = 0.5 * ( event.pageY + position.y );

// 				panEnd.set( x, y );

// 			}

// 			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

// 			pan( panDelta.x, panDelta.y );

// 			panStart.copy( panEnd );

// 		}

// 		function handleTouchMoveDolly( event ) {

// 			const position = getSecondPointerPosition( event );

// 			const dx = event.pageX - position.x;
// 			const dy = event.pageY - position.y;

// 			const distance = Math.sqrt( dx * dx + dy * dy );

// 			dollyEnd.set( 0, distance );

// 			dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

// 			dollyOut( dollyDelta.y );

// 			dollyStart.copy( dollyEnd );

// 			const centerX = ( event.pageX + position.x ) * 0.5;
// 			const centerY = ( event.pageY + position.y ) * 0.5;

// 			updateZoomParameters( centerX, centerY );

// 		}

// 		function handleTouchMoveDollyPan( event ) {

// 			if ( scope.enableZoom ) handleTouchMoveDolly( event );

// 			if ( scope.enablePan ) handleTouchMovePan( event );

// 		}

// 		function handleTouchMoveDollyRotate( event ) {

// 			if ( scope.enableZoom ) handleTouchMoveDolly( event );

// 			if ( scope.enableRotate ) handleTouchMoveRotate( event );

// 		}

// 		//
// 		// event handlers - FSM: listen for events and reset state
// 		//

// 		function onPointerDown( event ) {

// 			if ( scope.enabled === false ) return;

// 			if ( pointers.length === 0 ) {

// 				scope.domElement.setPointerCapture( event.pointerId );

// 				scope.domElement.addEventListener( 'pointermove', onPointerMove );
// 				scope.domElement.addEventListener( 'pointerup', onPointerUp );

// 			}

// 			//

// 			if ( isTrackingPointer( event ) ) return;

// 			//

// 			addPointer( event );

// 			if ( event.pointerType === 'touch' ) {

// 				onTouchStart( event );

// 			} else {

// 				onMouseDown( event );

// 			}

// 		}

// 		function onPointerMove( event ) {

// 			if ( scope.enabled === false ) return;

// 			if ( event.pointerType === 'touch' ) {

// 				onTouchMove( event );

// 			} else {

// 				onMouseMove( event );

// 			}

// 		}

// 		function onPointerUp( event ) {

// 			removePointer( event );

// 			switch ( pointers.length ) {

// 				case 0:

// 					scope.domElement.releasePointerCapture( event.pointerId );

// 					scope.domElement.removeEventListener( 'pointermove', onPointerMove );
// 					scope.domElement.removeEventListener( 'pointerup', onPointerUp );

// 					scope.dispatchEvent( _endEvent );

// 					state = STATE.NONE;

// 					break;

// 				case 1:

// 					const pointerId = pointers[ 0 ];
// 					const position = pointerPositions[ pointerId ];

// 					// minimal placeholder event - allows state correction on pointer-up
// 					onTouchStart( { pointerId: pointerId, pageX: position.x, pageY: position.y } );

// 					break;

// 			}

// 		}

// 		function onMouseDown( event ) {

// 			let mouseAction;

// 			switch ( event.button ) {

// 				case 0:

// 					mouseAction = scope.mouseButtons.LEFT;
// 					break;

// 				case 1:

// 					mouseAction = scope.mouseButtons.MIDDLE;
// 					break;

// 				case 2:

// 					mouseAction = scope.mouseButtons.RIGHT;
// 					break;

// 				default:

// 					mouseAction = - 1;

// 			}

// 			switch ( mouseAction ) {

// 				case THREE.MOUSE.DOLLY:

// 					if ( scope.enableZoom === false ) return;

// 					handleMouseDownDolly( event );

// 					state = STATE.DOLLY;

// 					break;

// 				case THREE.MOUSE.ROTATE:

// 					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

// 						if ( scope.enablePan === false ) return;

// 						handleMouseDownPan( event );

// 						state = STATE.PAN;

// 					} else {

// 						if ( scope.enableRotate === false ) return;

// 						handleMouseDownRotate( event );

// 						state = STATE.ROTATE;

// 					}

// 					break;

// 				case THREE.MOUSE.PAN:

// 					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

// 						if ( scope.enableRotate === false ) return;

// 						handleMouseDownRotate( event );

// 						state = STATE.ROTATE;

// 					} else {

// 						if ( scope.enablePan === false ) return;

// 						handleMouseDownPan( event );

// 						state = STATE.PAN;

// 					}

// 					break;

// 				default:

// 					state = STATE.NONE;

// 			}

// 			if ( state !== STATE.NONE ) {

// 				scope.dispatchEvent( _startEvent );

// 			}

// 		}

// 		function onMouseMove( event ) {

// 			switch ( state ) {

// 				case STATE.ROTATE:

// 					if ( scope.enableRotate === false ) return;

// 					handleMouseMoveRotate( event );

// 					break;

// 				case STATE.DOLLY:

// 					if ( scope.enableZoom === false ) return;

// 					handleMouseMoveDolly( event );

// 					break;

// 				case STATE.PAN:

// 					if ( scope.enablePan === false ) return;

// 					handleMouseMovePan( event );

// 					break;

// 			}

// 		}

// 		function onMouseWheel( event ) {

// 			if ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return;

// 			event.preventDefault();

// 			scope.dispatchEvent( _startEvent );

// 			handleMouseWheel( customWheelEvent( event ) );

// 			scope.dispatchEvent( _endEvent );

// 		}

// 		function customWheelEvent( event ) {

// 			const mode = event.deltaMode;

// 			// minimal wheel event altered to meet delta-zoom demand
// 			const newEvent = {
// 				clientX: event.clientX,
// 				clientY: event.clientY,
// 				deltaY: event.deltaY,
// 			};

// 			switch ( mode ) {

// 				case 1: // LINE_MODE
// 					newEvent.deltaY *= 16;
// 					break;

// 				case 2: // PAGE_MODE
// 					newEvent.deltaY *= 100;
// 					break;

// 			}

// 			// detect if event was triggered by pinching
// 			if ( event.ctrlKey && ! controlActive ) {

// 				newEvent.deltaY *= 10;

// 			}

// 			return newEvent;

// 		}

// 		function interceptControlDown( event ) {

// 			if ( event.key === 'Control' ) {

// 				controlActive = true;


// 				const document = scope.domElement.getRootNode(); // offscreen canvas compatibility

// 				document.addEventListener( 'keyup', interceptControlUp, { passive: true, capture: true } );

// 			}

// 		}

// 		function interceptControlUp( event ) {

// 			if ( event.key === 'Control' ) {

// 				controlActive = false;


// 				const document = scope.domElement.getRootNode(); // offscreen canvas compatibility

// 				document.removeEventListener( 'keyup', interceptControlUp, { passive: true, capture: true } );

// 			}

// 		}

// 		function onKeyDown( event ) {

// 			if ( scope.enabled === false || scope.enablePan === false ) return;

// 			handleKeyDown( event );

// 		}

// 		function onTouchStart( event ) {

// 			trackPointer( event );

// 			switch ( pointers.length ) {

// 				case 1:

// 					switch ( scope.touches.ONE ) {

// 						case TOUCH.ROTATE:

// 							if ( scope.enableRotate === false ) return;

// 							handleTouchStartRotate( event );

// 							state = STATE.TOUCH_ROTATE;

// 							break;

// 						case TOUCH.PAN:

// 							if ( scope.enablePan === false ) return;

// 							handleTouchStartPan( event );

// 							state = STATE.TOUCH_PAN;

// 							break;

// 						default:

// 							state = STATE.NONE;

// 					}

// 					break;

// 				case 2:

// 					switch ( scope.touches.TWO ) {

// 						case TOUCH.DOLLY_PAN:

// 							if ( scope.enableZoom === false && scope.enablePan === false ) return;

// 							handleTouchStartDollyPan( event );

// 							state = STATE.TOUCH_DOLLY_PAN;

// 							break;

// 						case TOUCH.DOLLY_ROTATE:

// 							if ( scope.enableZoom === false && scope.enableRotate === false ) return;

// 							handleTouchStartDollyRotate( event );

// 							state = STATE.TOUCH_DOLLY_ROTATE;

// 							break;

// 						default:

// 							state = STATE.NONE;

// 					}

// 					break;

// 				default:

// 					state = STATE.NONE;

// 			}

// 			if ( state !== STATE.NONE ) {

// 				scope.dispatchEvent( _startEvent );

// 			}

// 		}

// 		function onTouchMove( event ) {

// 			trackPointer( event );

// 			switch ( state ) {

// 				case STATE.TOUCH_ROTATE:

// 					if ( scope.enableRotate === false ) return;

// 					handleTouchMoveRotate( event );

// 					scope.update();

// 					break;

// 				case STATE.TOUCH_PAN:

// 					if ( scope.enablePan === false ) return;

// 					handleTouchMovePan( event );

// 					scope.update();

// 					break;

// 				case STATE.TOUCH_DOLLY_PAN:

// 					if ( scope.enableZoom === false && scope.enablePan === false ) return;

// 					handleTouchMoveDollyPan( event );

// 					scope.update();

// 					break;

// 				case STATE.TOUCH_DOLLY_ROTATE:

// 					if ( scope.enableZoom === false && scope.enableRotate === false ) return;

// 					handleTouchMoveDollyRotate( event );

// 					scope.update();

// 					break;

// 				default:

// 					state = STATE.NONE;

// 			}

// 		}

// 		function onContextMenu( event ) {

// 			if ( scope.enabled === false ) return;

// 			event.preventDefault();

// 		}

// 		function addPointer( event ) {

// 			pointers.push( event.pointerId );

// 		}

// 		function removePointer( event ) {

// 			delete pointerPositions[ event.pointerId ];

// 			for ( let i = 0; i < pointers.length; i ++ ) {

// 				if ( pointers[ i ] == event.pointerId ) {

// 					pointers.splice( i, 1 );
// 					return;

// 				}

// 			}

// 		}

// 		function isTrackingPointer( event ) {

// 			for ( let i = 0; i < pointers.length; i ++ ) {

// 				if ( pointers[ i ] == event.pointerId ) return true;

// 			}

// 			return false;

// 		}

// 		function trackPointer( event ) {

// 			let position = pointerPositions[ event.pointerId ];

// 			if ( position === undefined ) {

// 				position = new THREE.Vector2();
// 				pointerPositions[ event.pointerId ] = position;

// 			}

// 			position.set( event.pageX, event.pageY );

// 		}

// 		function getSecondPointerPosition( event ) {

// 			const pointerId = ( event.pointerId === pointers[ 0 ] ) ? pointers[ 1 ] : pointers[ 0 ];

// 			return pointerPositions[ pointerId ];

// 		}

// 		//

// 		scope.domElement.addEventListener( 'contextmenu', onContextMenu );

// 		scope.domElement.addEventListener( 'pointerdown', onPointerDown );
// 		scope.domElement.addEventListener( 'pointercancel', onPointerUp );
// 		scope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );

// 		const document = scope.domElement.getRootNode(); // offscreen canvas compatibility

// 		document.addEventListener( 'keydown', interceptControlDown, { passive: true, capture: true } );

// 		// force an update at start

// 		this.update();

// 	}

// }


// //////////////////////////////////////
// // 6. HTMLMesh  //
// //////////////////////////////////////
// class HTMLMesh extends THREE.Mesh {

// 	constructor( dom ) {

// 		const texture = new HTMLTexture( dom );

// 		const geometry = new PlaneGeometry( texture.image.width * 0.001, texture.image.height * 0.001 );
// 		const material = new MeshBasicMaterial( { map: texture, toneMapped: false, transparent: true } );

// 		super( geometry, material );

// 		function onEvent( event ) {

// 			material.map.dispatchDOMEvent( event );

// 		}

// 		this.addEventListener( 'mousedown', onEvent );
// 		this.addEventListener( 'mousemove', onEvent );
// 		this.addEventListener( 'mouseup', onEvent );
// 		this.addEventListener( 'click', onEvent );

// 		this.dispose = function () {

// 			geometry.dispose();
// 			material.dispose();

// 			material.map.dispose();

// 			canvases.delete( dom );

// 			this.removeEventListener( 'mousedown', onEvent );
// 			this.removeEventListener( 'mousemove', onEvent );
// 			this.removeEventListener( 'mouseup', onEvent );
// 			this.removeEventListener( 'click', onEvent );

// 		};

// 	}

// }

// class HTMLTexture extends THREE.CanvasTexture {

// 	constructor( dom ) {

// 		super( html2canvas( dom ) );

// 		this.dom = dom;

// 		this.anisotropy = 16;
// 		this.colorSpace = SRGBColorSpace;
// 		this.minFilter = LinearFilter;
// 		this.magFilter = LinearFilter;

// 		// Create an observer on the DOM, and run html2canvas update in the next loop
// 		const observer = new MutationObserver( () => {

// 			if ( ! this.scheduleUpdate ) {

// 				// ideally should use xr.requestAnimationFrame, here setTimeout to avoid passing the renderer
// 				this.scheduleUpdate = setTimeout( () => this.update(), 16 );

// 			}

// 		} );

// 		const config = { attributes: true, childList: true, subtree: true, characterData: true };
// 		observer.observe( dom, config );

// 		this.observer = observer;

// 	}

// 	dispatchDOMEvent( event ) {

// 		if ( event.data ) {

// 			htmlevent( this.dom, event.type, event.data.x, event.data.y );

// 		}

// 	}

// 	update() {

// 		this.image = html2canvas( this.dom );
// 		this.needsUpdate = true;

// 		this.scheduleUpdate = null;

// 	}

// 	dispose() {

// 		if ( this.observer ) {

// 			this.observer.disconnect();

// 		}

// 		this.scheduleUpdate = clearTimeout( this.scheduleUpdate );

// 		super.dispose();

// 	}

// }


// const canvases = new WeakMap();

// function html2canvas( element ) {

// 	const range = document.createRange();
// 	const color = new Color();

// 	function Clipper( context ) {

// 		const clips = [];
// 		let isClipping = false;

// 		function doClip() {

// 			if ( isClipping ) {

// 				isClipping = false;
// 				context.restore();

// 			}

// 			if ( clips.length === 0 ) return;

// 			let minX = - Infinity, minY = - Infinity;
// 			let maxX = Infinity, maxY = Infinity;

// 			for ( let i = 0; i < clips.length; i ++ ) {

// 				const clip = clips[ i ];

// 				minX = Math.max( minX, clip.x );
// 				minY = Math.max( minY, clip.y );
// 				maxX = Math.min( maxX, clip.x + clip.width );
// 				maxY = Math.min( maxY, clip.y + clip.height );

// 			}

// 			context.save();
// 			context.beginPath();
// 			context.rect( minX, minY, maxX - minX, maxY - minY );
// 			context.clip();

// 			isClipping = true;

// 		}

// 		return {

// 			add: function ( clip ) {

// 				clips.push( clip );
// 				doClip();

// 			},

// 			remove: function () {

// 				clips.pop();
// 				doClip();

// 			}

// 		};

// 	}

// 	function drawText( style, x, y, string ) {

// 		if ( string !== '' ) {

// 			if ( style.textTransform === 'uppercase' ) {

// 				string = string.toUpperCase();

// 			}

// 			context.font = style.fontWeight + ' ' + style.fontSize + ' ' + style.fontFamily;
// 			context.textBaseline = 'top';
// 			context.fillStyle = style.color;
// 			context.fillText( string, x, y + parseFloat( style.fontSize ) * 0.1 );

// 		}

// 	}

// 	function buildRectPath( x, y, w, h, r ) {

// 		if ( w < 2 * r ) r = w / 2;
// 		if ( h < 2 * r ) r = h / 2;

// 		context.beginPath();
// 		context.moveTo( x + r, y );
// 		context.arcTo( x + w, y, x + w, y + h, r );
// 		context.arcTo( x + w, y + h, x, y + h, r );
// 		context.arcTo( x, y + h, x, y, r );
// 		context.arcTo( x, y, x + w, y, r );
// 		context.closePath();

// 	}

// 	function drawBorder( style, which, x, y, width, height ) {

// 		const borderWidth = style[ which + 'Width' ];
// 		const borderStyle = style[ which + 'Style' ];
// 		const borderColor = style[ which + 'Color' ];

// 		if ( borderWidth !== '0px' && borderStyle !== 'none' && borderColor !== 'transparent' && borderColor !== 'rgba(0, 0, 0, 0)' ) {

// 			context.strokeStyle = borderColor;
// 			context.lineWidth = parseFloat( borderWidth );
// 			context.beginPath();
// 			context.moveTo( x, y );
// 			context.lineTo( x + width, y + height );
// 			context.stroke();

// 		}

// 	}

// 	function drawElement( element, style ) {

// 		// Do not render invisible elements, comments and scripts.
// 		if ( element.nodeType === Node.COMMENT_NODE || element.nodeName === 'SCRIPT' || ( element.style && element.style.display === 'none' ) ) {

// 			return;

// 		}

// 		let x = 0, y = 0, width = 0, height = 0;

// 		if ( element.nodeType === Node.TEXT_NODE ) {

// 			// text

// 			range.selectNode( element );

// 			const rect = range.getBoundingClientRect();

// 			x = rect.left - offset.left - 0.5;
// 			y = rect.top - offset.top - 0.5;
// 			width = rect.width;
// 			height = rect.height;

// 			drawText( style, x, y, element.nodeValue.trim() );

// 		} else if ( element instanceof HTMLCanvasElement ) {

// 			// Canvas element

// 			const rect = element.getBoundingClientRect();

// 			x = rect.left - offset.left - 0.5;
// 			y = rect.top - offset.top - 0.5;

// 		        context.save();
// 			const dpr = window.devicePixelRatio;
// 			context.scale( 1 / dpr, 1 / dpr );
// 			context.drawImage( element, x, y );
// 			context.restore();

// 		} else if ( element instanceof HTMLImageElement ) {

// 			const rect = element.getBoundingClientRect();

// 			x = rect.left - offset.left - 0.5;
// 			y = rect.top - offset.top - 0.5;
// 			width = rect.width;
// 			height = rect.height;

// 			context.drawImage( element, x, y, width, height );

// 		} else {

// 			const rect = element.getBoundingClientRect();

// 			x = rect.left - offset.left - 0.5;
// 			y = rect.top - offset.top - 0.5;
// 			width = rect.width;
// 			height = rect.height;

// 			style = window.getComputedStyle( element );

// 			// Get the border of the element used for fill and border

// 			buildRectPath( x, y, width, height, parseFloat( style.borderRadius ) );

// 			const backgroundColor = style.backgroundColor;

// 			if ( backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)' ) {

// 				context.fillStyle = backgroundColor;
// 				context.fill();

// 			}

// 			// If all the borders match then stroke the round rectangle

// 			const borders = [ 'borderTop', 'borderLeft', 'borderBottom', 'borderRight' ];

// 			let match = true;
// 			let prevBorder = null;

// 			for ( const border of borders ) {

// 				if ( prevBorder !== null ) {

// 					match = ( style[ border + 'Width' ] === style[ prevBorder + 'Width' ] ) &&
// 					( style[ border + 'Color' ] === style[ prevBorder + 'Color' ] ) &&
// 					( style[ border + 'Style' ] === style[ prevBorder + 'Style' ] );

// 				}

// 				if ( match === false ) break;

// 				prevBorder = border;

// 			}

// 			if ( match === true ) {

// 				// They all match so stroke the rectangle from before allows for border-radius

// 				const width = parseFloat( style.borderTopWidth );

// 				if ( style.borderTopWidth !== '0px' && style.borderTopStyle !== 'none' && style.borderTopColor !== 'transparent' && style.borderTopColor !== 'rgba(0, 0, 0, 0)' ) {

// 					context.strokeStyle = style.borderTopColor;
// 					context.lineWidth = width;
// 					context.stroke();

// 				}

// 			} else {

// 				// Otherwise draw individual borders

// 				drawBorder( style, 'borderTop', x, y, width, 0 );
// 				drawBorder( style, 'borderLeft', x, y, 0, height );
// 				drawBorder( style, 'borderBottom', x, y + height, width, 0 );
// 				drawBorder( style, 'borderRight', x + width, y, 0, height );

// 			}

// 			if ( element instanceof HTMLInputElement ) {

// 				let accentColor = style.accentColor;

// 				if ( accentColor === undefined || accentColor === 'auto' ) accentColor = style.color;

// 				color.set( accentColor );

// 				const luminance = Math.sqrt( 0.299 * ( color.r ** 2 ) + 0.587 * ( color.g ** 2 ) + 0.114 * ( color.b ** 2 ) );
// 				const accentTextColor = luminance < 0.5 ? 'white' : '#111111';

// 				if ( element.type === 'radio' ) {

// 					buildRectPath( x, y, width, height, height );

// 					context.fillStyle = 'white';
// 					context.strokeStyle = accentColor;
// 					context.lineWidth = 1;
// 					context.fill();
// 					context.stroke();

// 					if ( element.checked ) {

// 						buildRectPath( x + 2, y + 2, width - 4, height - 4, height );

// 						context.fillStyle = accentColor;
// 						context.strokeStyle = accentTextColor;
// 						context.lineWidth = 2;
// 						context.fill();
// 						context.stroke();

// 					}

// 				}

// 				if ( element.type === 'checkbox' ) {

// 					buildRectPath( x, y, width, height, 2 );

// 					context.fillStyle = element.checked ? accentColor : 'white';
// 					context.strokeStyle = element.checked ? accentTextColor : accentColor;
// 					context.lineWidth = 1;
// 					context.stroke();
// 					context.fill();

// 					if ( element.checked ) {

// 						const currentTextAlign = context.textAlign;

// 						context.textAlign = 'center';

// 						const properties = {
// 							color: accentTextColor,
// 							fontFamily: style.fontFamily,
// 							fontSize: height + 'px',
// 							fontWeight: 'bold'
// 						};

// 						drawText( properties, x + ( width / 2 ), y, '✔' );

// 						context.textAlign = currentTextAlign;

// 					}

// 				}

// 				if ( element.type === 'range' ) {

// 					const [ min, max, value ] = [ 'min', 'max', 'value' ].map( property => parseFloat( element[ property ] ) );
// 					const position = ( ( value - min ) / ( max - min ) ) * ( width - height );

// 					buildRectPath( x, y + ( height / 4 ), width, height / 2, height / 4 );
// 					context.fillStyle = accentTextColor;
// 					context.strokeStyle = accentColor;
// 					context.lineWidth = 1;
// 					context.fill();
// 					context.stroke();

// 					buildRectPath( x, y + ( height / 4 ), position + ( height / 2 ), height / 2, height / 4 );
// 					context.fillStyle = accentColor;
// 					context.fill();

// 					buildRectPath( x + position, y, height, height, height / 2 );
// 					context.fillStyle = accentColor;
// 					context.fill();

// 				}

// 				if ( element.type === 'color' || element.type === 'text' || element.type === 'number' ) {

// 					clipper.add( { x: x, y: y, width: width, height: height } );

// 					drawText( style, x + parseInt( style.paddingLeft ), y + parseInt( style.paddingTop ), element.value );

// 					clipper.remove();

// 				}

// 			}

// 		}

// 		/*
// 		// debug
// 		context.strokeStyle = '#' + Math.random().toString( 16 ).slice( - 3 );
// 		context.strokeRect( x - 0.5, y - 0.5, width + 1, height + 1 );
// 		*/

// 		const isClipping = style.overflow === 'auto' || style.overflow === 'hidden';

// 		if ( isClipping ) clipper.add( { x: x, y: y, width: width, height: height } );

// 		for ( let i = 0; i < element.childNodes.length; i ++ ) {

// 			drawElement( element.childNodes[ i ], style );

// 		}

// 		if ( isClipping ) clipper.remove();

// 	}

// 	const offset = element.getBoundingClientRect();

// 	let canvas = canvases.get( element );

// 	if ( canvas === undefined ) {

// 		canvas = document.createElement( 'canvas' );
// 		canvas.width = offset.width;
// 		canvas.height = offset.height;
// 		canvases.set( element, canvas );

// 	}

// 	const context = canvas.getContext( '2d'/*, { alpha: false }*/ );

// 	const clipper = new Clipper( context );

// 	// console.time( 'drawElement' );

// 	context.clearRect( 0, 0, canvas.width, canvas.height );

// 	drawElement( element );

// 	// console.timeEnd( 'drawElement' );

// 	return canvas;

// }

// function htmlevent( element, event, x, y ) {

// 	const mouseEventInit = {
// 		clientX: ( x * element.offsetWidth ) + element.offsetLeft,
// 		clientY: ( y * element.offsetHeight ) + element.offsetTop,
// 		view: element.ownerDocument.defaultView
// 	};

// 	window.dispatchEvent( new MouseEvent( event, mouseEventInit ) );

// 	const rect = element.getBoundingClientRect();

// 	x = x * rect.width + rect.left;
// 	y = y * rect.height + rect.top;

// 	function traverse( element ) {

// 		if ( element.nodeType !== Node.TEXT_NODE && element.nodeType !== Node.COMMENT_NODE ) {

// 			const rect = element.getBoundingClientRect();

// 			if ( x > rect.left && x < rect.right && y > rect.top && y < rect.bottom ) {

// 				element.dispatchEvent( new MouseEvent( event, mouseEventInit ) );

// 				if ( element instanceof HTMLInputElement && element.type === 'range' && ( event === 'mousedown' || event === 'click' ) ) {

// 					const [ min, max ] = [ 'min', 'max' ].map( property => parseFloat( element[ property ] ) );

// 					const width = rect.width;
// 					const offsetX = x - rect.x;
// 					const proportion = offsetX / width;
// 					element.value = min + ( max - min ) * proportion;
// 					element.dispatchEvent( new InputEvent( 'input', { bubbles: true } ) );

// 				}

// 			}

// 			for ( let i = 0; i < element.childNodes.length; i ++ ) {

// 				traverse( element.childNodes[ i ] );

// 			}

// 		}

// 	}

// 	traverse( element );

// }



//////////////////////////////////////
// 6. GestureControlModule  //
//////////////////////////////////////

class GestureControlModule {
  constructor() {
    this.leftHandPosition = new THREE.Vector3();
    this.rightHandPosition = new THREE.Vector3();
    this.prevLeftHandPosition = new THREE.Vector3();
    this.prevRightHandPosition = new THREE.Vector3();
    this.isLeftPinching = false;
    this.isRightPinching = false;

    this.currentScale = 1.0;
    this.currentRotY = 0;
    this.currentTranslation = new THREE.Vector3();
  }

  reset() {
    this.currentScale = 1.0;
    this.currentRotY = 0;
    this.currentTranslation.set(0, 0, 0);
    this.leftHandPosition.set(0, 0, 0);
    this.rightHandPosition.set(0, 0, 0);
    this.prevLeftHandPosition.set(0, 0, 0);
    this.prevRightHandPosition.set(0, 0, 0);
    this.isLeftPinching = false;
    this.isRightPinching = false;
  }

  updateLeftHand(pos) {
    this.leftHandPosition.set(pos.x, pos.y, pos.z);
  }

  updateRightHand(pos) {
    this.rightHandPosition.set(pos.x, pos.y, pos.z);
  }

  leftPinchStart() {
    this.isLeftPinching = true;
  }

  leftPinchEnd() {
    this.isLeftPinching = false;
  }

  rightPinchStart() {
    this.isRightPinching = true;
  }

  rightPinchEnd() {
    this.isRightPinching = false;
  }

  getHandAngle(left, right) {
    let dz = left.z - right.z;
    let dx = left.x - right.x;
    if (dx === 0 && dz === 0) {
      return 0;
    }
    return -Math.atan2(dz, dx);
  }

  normalizeAngle(angle) {
    if (angle > Math.PI) {
      angle -= 2 * Math.PI;
    } else if (angle < -Math.PI) {
      angle += 2 * Math.PI;
    }
    return angle;
  }

  getCurrentTransformation() {
    let transformationMatrix = new THREE.Matrix4();

    // Create a scaling matrix
    let scaleMatrix = new THREE.Matrix4().makeScale(this.currentScale, this.currentScale, this.currentScale);

    // Create a rotation matrix
    let rotationMatrix = new THREE.Matrix4().makeRotationY(this.currentRotY);

    // Create a translation matrix
    let translationMatrix = new THREE.Matrix4().makeTranslation(
      this.currentTranslation.x,
      this.currentTranslation.y,
      this.currentTranslation.z
    );

    transformationMatrix.multiply(translationMatrix);
    transformationMatrix.multiply(scaleMatrix);
    transformationMatrix.multiply(rotationMatrix);

    return transformationMatrix;
  }

  updateTransformation(world_group_position, mesh_position) {
    if (this.isLeftPinching && this.isRightPinching) {
      // Use the average of both left and right translation
      let translationDeltaLeft = this.leftHandPosition.clone().sub(this.prevLeftHandPosition);
      let translationDeltaRight = this.rightHandPosition.clone().sub(this.prevRightHandPosition);
      let translationDelta = translationDeltaLeft.add(translationDeltaRight).multiplyScalar(0.5);
      this.currentTranslation.add(translationDelta);
    }

    let handDistance = this.leftHandPosition.distanceTo(this.rightHandPosition);
    if (this.isLeftPinching && this.isRightPinching && handDistance > 0.1) {
      let prevDistance = this.prevLeftHandPosition.distanceTo(this.prevRightHandPosition);
      let currentDistance = this.leftHandPosition.distanceTo(this.rightHandPosition);
      let scaleDelta = currentDistance / prevDistance;
      this.currentScale *= scaleDelta;
      this.currentScale = Math.max(0.1, Math.min(this.currentScale, 2));

      // Scaling the mesh down moves the grasp point toward the mesh center
      // To compensate, translate the mesh toward the grasp point (if scaleDelta < 1) or away from the grasp point (if scaleDelta > 1)
      let grasp_point = this.leftHandPosition.clone().add(this.rightHandPosition).multiplyScalar(0.5);
      grasp_point.sub(world_group_position);
      grasp_point.sub(mesh_position);
      this.currentTranslation.add(grasp_point.clone().multiplyScalar(1.0 - scaleDelta));
      this.currentTranslation.x = Math.max(-10.0, Math.min(this.currentTranslation.x, 10.0));
      this.currentTranslation.y = Math.max(-10.0, Math.min(this.currentTranslation.y, 10.0));
      this.currentTranslation.z = Math.max(-5.0, Math.min(this.currentTranslation.z, 5.0));

      // Rotate only about the Y axis
      let rotationDelta = this.normalizeAngle(this.getHandAngle(this.leftHandPosition, this.rightHandPosition) - this.getHandAngle(this.prevLeftHandPosition, this.prevRightHandPosition));
      this.currentRotY += rotationDelta;

      let rotation_motion = new THREE.Vector3(-grasp_point.z, 0, grasp_point.x);
      rotation_motion.multiplyScalar(Math.max(Math.min(rotationDelta, 0.1), -0.1));
      this.currentTranslation.add(rotation_motion);
    }
    this.prevLeftHandPosition.copy(this.leftHandPosition);
    this.prevRightHandPosition.copy(this.rightHandPosition);
  }
}


const gesture_control = new GestureControlModule();

let enable_debug_text = false; // Turn this on if you want to use debugLog() or setDebugText().
let debug_text_mesh, debug_text_div;
let debug_log = "";
let debug_msg_count = 0;


let container, camera, scene, renderer;
let format;
let error_message_div;


let media_mesh;
let world_group; // A THREE.Group that stores all of the meshes (foreground and background), so they can be transformed together by modifying the group.
let interface_group; // A separate Group for 3D interface components


let video;
let texture;
let nonvr_menu_fade_counter = 1;
let mouse_is_down = false;

let toggle_layer0 = true;
let toggle_layer1 = true;
let toggle_layer2 = true;

let prev_mouse_u = 0.5;
let prev_mouse_v = 0.5;
let cam_drag_u = 0.0;
let cam_drag_v = 0.0;
let right_mouse_is_down = false;

let nonvr_controls;
let is_buffering_at = performance.now();
let vr_session_active = false; // true if we are in VR
// Used to keep track of whether a click or a drag occured. When a mousedown event occurs,
// this becomes true, and a timer starts. When the timer expires, it becomes false.
// If the mouseup even happens before the timer, it will be counted as a click.
let maybe_click = false;
let delay1frame_reset = false; // The sessionstart event happens one frame too early. We need to wait 1 frame to reset the view after entering VR.
let photo_mode = false;
let embed_mode = false;
let cam_mode = "orbit";

let lock_position = false;
let orbit_controls;
let mouse_last_moved_time = 0;

let has_played_video = false;

let get_vr_button;

let looking_glass_config;

// Used for IMU based control on mobile
let got_orientation_data = false;
let init_orientation_a = 0;
let init_orientation_b = 0;
let init_orientation_c = 0;

let mobile_drag_u = 0.0;
let mobile_drag_v = 0.0;

// Used for programmatic camera animation
let anim_x = 0.15;
let anim_y = 0.10;
let anim_z = 0.05;
let anim_u = 0.15;
let anim_v = 0.10;
let anim_x_speed = 7500;
let anim_y_speed = 5100;
let anim_z_speed = 6100;
let anim_u_speed = 4500;
let anim_v_speed = 5100;

let AUTO_CAM_MOVE_TIME = 5000;

const BUFFERING_TIMEOUT = 500;
const TRANSITION_ANIM_DURATION = 8000;
let transition_start_timer;
let enable_intro_animation;


var ua = navigator.userAgent;
var is_firefox = ua.indexOf("Firefox") != -1;
var is_oculus = (ua.indexOf("Oculus") != -1);
var is_chrome =  (ua.indexOf("Chrome")  != -1) || is_oculus;
var is_safarish =  (ua.indexOf("Safari")  != -1) && (!is_chrome || (ua.indexOf("Mac")  != -1)); // This can still be true on Chrome for Mac...
var is_ios = ua.match(/iPhone|iPad|iPod/i);

function byId(id) { return document.getElementById( id ); };

function filenameExtension(filename) { return filename.split('.').pop(); }

function loadJSON(json_path, callback) {
  var xobj = new XMLHttpRequest();
  xobj.overrideMimeType("application/json");
  xobj.open('GET', json_path, true);
  xobj.onreadystatechange = function() {
    if (xobj.readyState == 4 && xobj.status == "200") { callback(JSON.parse(xobj.responseText)); }
  };
  xobj.send(null);
}

function setBodyStyle() {
  document.body.style.margin              = "0px";
  document.body.style.padding             = "0px";
}

function makeUnselectable(element) {
  element.style["-webkit-touch-callout"]  = "none";
  element.style["-webkit-user-select"]    = "none";
  element.style["-khtml-user-select"]     = "none";
  element.style["-moz-user-select"]       = "none";
  element.style["-ms-user-select"]        = "none";
  element.style["user-select"]            = "none";
  element.style["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)";
  element.style["-webkit-touch-callout"]  = "none";
  element.style.pointerEvents = "none";
}

function trackMouseStatus(element) {
  element.addEventListener('mouseover', function() { element.mouse_is_over = true; });
  element.addEventListener('mouseout', function() { element.mouse_is_over = false; });
}

function makeNonVrControls() {

  nonvr_controls = document.createElement("div");
  nonvr_controls.id = "nonvr_controls";
  nonvr_controls.style["margin"]            = "auto";
  nonvr_controls.style["position"]          = "absolute";
  nonvr_controls.style["top"]               = "50%";
  nonvr_controls.style["left"]              = "50%";
  nonvr_controls.style["transform"]         = "translate(-50%, -50%)";

  let sz = "64px";
  nonvr_controls.style["width"]             = sz;
  nonvr_controls.style["height"]            = sz;
  nonvr_controls.style["cursor"]            = "pointer";

  const play_button = document.createElement("img");
  play_button.id                            = "play_button";
  play_button.src                           = play_buttonSrc;
  play_button.draggable                     = false;
  play_button.style.display                 = "none";
  play_button.style.width                   = sz;
  play_button.style.height                  = sz;

  const pause_button = document.createElement("img");
  pause_button.id                           = "pause_button";
  pause_button.src                          = pause_buttonSrc;
  pause_button.draggable                    = false;
  pause_button.style.display                = "none";
  pause_button.style.width                  = sz;
  pause_button.style.height                 = sz;

  const rewind_button = document.createElement("img");
  rewind_button.id                          = "rewind_button";
  rewind_button.src                         = rewind_buttonSrc;
  rewind_button.draggable                   = false;
  rewind_button.style.display               = "none";
  rewind_button.style.width                 = sz;
  rewind_button.style.height                = sz;

  const buffering_button = document.createElement("img");
  buffering_button.id                       = "buffering_button";
  buffering_button.src                      = spinner;
  buffering_button.draggable                = false;
  buffering_button.style.display            = "none";
  buffering_button.style.opacity            = 0.5;
  buffering_button.style.width              = sz;
  buffering_button.style.height             = sz;

  var spinner_rotation_angle = 0;
  setInterval(function() {
    buffering_button.style.transform = "rotate(" + spinner_rotation_angle + "deg)";
    spinner_rotation_angle += 5;
  }, 16);

  makeUnselectable(nonvr_controls);
  makeUnselectable(buffering_button);
  nonvr_controls.appendChild(play_button);
  nonvr_controls.appendChild(pause_button);
  nonvr_controls.appendChild(rewind_button);
  nonvr_controls.appendChild(buffering_button);

  container.appendChild(nonvr_controls);
}

function debugLog(message) {
  ++debug_msg_count;
  if (debug_msg_count > 30) {
    //return; // HACK: stop adding new messages once we reach a limit
    debug_log = "";
    debug_msg_count = 0;
  }
  debug_log += message + "<br>";
  setDebugText(debug_log);
}

function setDebugText(message) {
  if (!enable_debug_text) return;
  debug_text_div.innerHTML = message;
}

function handleGenericButtonPress() {
  if (photo_mode) {
    // TODO: Decide on a way to reset view that doesn't interfere with gesture controls
    //resetVRToCenter();
  } else {
    playVideoIfReady();
  }
}



function playVideoIfReady() {
  if (!video) return;

  video.play();
  has_played_video = true;
}

function pauseVideo() {
  if (photo_mode) return;

  nonvr_menu_fade_counter = 60;
  video.pause();
}

function toggleVideoPlayPause() {
  if (photo_mode) return;

  nonvr_menu_fade_counter = 60;

  const video_is_playing = !!(video.currentTime > 0 && !video.paused && !video.ended && video.readyState > 2);
  if (video_is_playing || buffering_at) {
    is_buffering_at = false;
    video.pause();
  } else {
    playVideoIfReady();
  }
}

function handleNonVrPlayButton() {
  playVideoIfReady();
}

function handleNonVrPauseButton() {
  video.pause();
}


function onWindowResize() {
  // In embed mode, use the width and height of the container div.
  let width = embed_mode ? container.clientWidth : window.innerWidth;
  let height = embed_mode ? container.clientHeight : window.innerHeight;
  camera.aspect = width / height;
  renderer.setSize(width, height);
  camera.updateProjectionMatrix();
}

function updateControlsAndButtons() {
  if (!nonvr_controls) return;

  const video_is_playing = video && !!(video.currentTime > 0 && !video.paused && !video.ended && video.readyState >= 2);
  if (video) {
    // Fade out but only if the mouse is not over a button
    if (!nonvr_controls.mouse_is_over) {
      --nonvr_menu_fade_counter;
    }
    nonvr_menu_fade_counter = Math.max(-60, nonvr_menu_fade_counter); // Allowing this to go negative means it takes a couple of frames of motion for it to become visible.


    var opacity = video.ended || is_buffering_at ? 1.0 : Math.min(1.0, nonvr_menu_fade_counter / 30.0);
    opacity *= nonvr_controls.mouse_is_over || is_buffering_at ? 1.0 : 0.7;

    if (!video_is_playing) {
      opacity = 1.0; // always show controls before playing. This is important for iOS where the video won't load without an interaction!
    }
  }

  nonvr_controls.style.opacity = opacity;

  if (video && !has_played_video && is_ios) {
    byId("play_button").style.display   = "none";  //"inline";
    byId("pause_button").style.display  = "none";
    byId("rewind_button").style.display = "none";
    byId("buffering_button").style.display = "none";
    return;
  }

  if (is_buffering_at && performance.now() - is_buffering_at > BUFFERING_TIMEOUT) {

    byId("play_button").style.display   = "none";
    byId("pause_button").style.display  = "none";
    byId("rewind_button").style.display = "none";
    byId("buffering_button").style.display = "inline";
    return;
  }

  if (video && video.ended) {
    byId("play_button").style.display   = "none";
    byId("pause_button").style.display  = "none";
    byId("buffering_button").style.display = "none";
    byId("rewind_button").style.display = "inline";
    return;
  }

  if (!video || nonvr_menu_fade_counter <= 0) {
    byId("play_button").style.display   = "none";
    byId("pause_button").style.display  = "none";
    byId("rewind_button").style.display = "none";
    byId("buffering_button").style.display = "none";
    return;
  }

  if (video_is_playing) {
    byId("play_button").style.display   = "none";
    byId("pause_button").style.display  = "none"; // "inline";
    byId("rewind_button").style.display = "none";
    byId("buffering_button").style.display = "none";
    return;
  }

  if (!video_is_playing && video.readyState >= 2) {
    byId("play_button").style.display   = "none"; // "inline";
    byId("pause_button").style.display  = "none";
    byId("rewind_button").style.display = "none";
    byId("buffering_button").style.display = "none";
    return;
  }
}

function startAnimatedTransitionEffect() {
  if (enable_intro_animation) {
    transition_start_timer = performance.now();
  }
}

function setVisibilityForLayerMeshes(l, v) {
  if (format == "ldi3") {
    for (var m of media_mesh.layer_to_meshes[l]) { m.visible = v; }
  }
}

function updateCameraPosition() {
  

  if (cam_mode == "first_person" && !got_orientation_data) {
    // If in non-VR and not moving the mouse, show that it's 3D using a nice gentle rotation
    if (Date.now() - mouse_last_moved_time > AUTO_CAM_MOVE_TIME) {
      let x = anim_x * Math.sin(Date.now() / anim_x_speed * Math.PI) * 0.5;
      let y = anim_y * Math.sin(Date.now() / anim_y_speed * Math.PI) * 0.5;
      let z = anim_z * Math.sin(Date.now() / anim_z_speed * Math.PI) * 0.5;
      camera.position.set(x, y, z);
      let u = anim_u * Math.sin(Date.now() / anim_u_speed * Math.PI) * 0.5;
      let v = anim_v * Math.sin(Date.now() / anim_v_speed * Math.PI) * 0.5;
      camera.lookAt(u, v, -4.0);
      camera.updateProjectionMatrix();
    } else {
      if (!right_mouse_is_down) {
        cam_drag_u *= 0.97;
        cam_drag_v *= 0.97;
      }
      camera.position.set(-prev_mouse_u * 0.2 + cam_drag_u, prev_mouse_v * 0.2 + cam_drag_v, 0.0);
      camera.lookAt(cam_drag_u, cam_drag_v, -0.3);
    }
  } else if (cam_mode == "orbit" && !is_ios) {
    let t = 1.0;
    if (transition_start_timer) {
      t = Math.min(1.0, (performance.now() - transition_start_timer) / TRANSITION_ANIM_DURATION);
    }
    // Swoop-in animation, displayed in the initial TRANSITION_ANIM_DURATION seconds
    if (t < 1.0) {
      let x = (1 - t)*(1 - t) * -5.0;
      let y = (1 - t)*(1 - t) * 3.0;
      let z = (1 - t)*(1 - t) * 7.0;
      // Set target0 and position0 then reset() to update the private camera position
      orbit_controls.target0.set(0, 0, -1.0);
      orbit_controls.position0.set(x, y, z);
      orbit_controls.reset();
    } else if (Date.now() - mouse_last_moved_time > AUTO_CAM_MOVE_TIME) {
      // Idle animation, only displayed after the initial animation and when idle
      var xt = performance.now();
      if (transition_start_timer) {
        xt -= (transition_start_timer + TRANSITION_ANIM_DURATION);
      }
      let x = anim_x * Math.sin(xt / anim_x_speed * Math.PI) * 0.5;
      orbit_controls.target0.set(x, 0, -1.0);
      orbit_controls.position0.set(-2.0 * x, 0, .0);
      orbit_controls.reset();
    }
    orbit_controls.update();
  }
}


function render() {
  // The fragment shader uses the distance from the camera to the origin to determine how
  // aggressively to fade out fragments that might be part of a streaky triangle. We need
  // to compute that distance differently depending on whether we are in VR or not.
  var novr_camera_position = camera.position;

  
  updateControlsAndButtons();
  if (lock_position) { resetVRToCenter(); }

  updateCameraPosition();

  if (format != "vr180") {
    media_mesh.matrix = gesture_control.getCurrentTransformation();
    media_mesh.matrix.decompose(media_mesh.position, media_mesh.quaternion, media_mesh.scale);
  }

  if (transition_start_timer) {
    const t = Math.min(1.0, (performance.now() - transition_start_timer) / TRANSITION_ANIM_DURATION);
    media_mesh.uniforms.uEffectRadius.value =
      Math.min(0.6 / ((1.0 - Math.pow(t, 0.2)) + 1e-6), 51); // HACK: the max radius of the mesh is 50, so this goes past it (which we want!)
  }

  // HACK: The video texture doesn't update as it should on Vision Pro, so here' well force it.
  if (is_safarish && video != undefined && !photo_mode && texture.source.data.videoWidth > 0) {
    texture.needsUpdate = true;
  }

  // Render each layer in order, clearing the depth buffer between. This is important
  // to get alpha blending right.
  renderer.clearColor();
  renderer.clearDepth();
  world_group.visible = true;
  interface_group.visible = false;
  if (toggle_layer0) {
    setVisibilityForLayerMeshes(0, true);
    setVisibilityForLayerMeshes(1, false);
    setVisibilityForLayerMeshes(2, false);
    renderer.render(scene, camera);
  }
  if (toggle_layer1) {
    setVisibilityForLayerMeshes(0, false);
    setVisibilityForLayerMeshes(1, true);
    setVisibilityForLayerMeshes(2, false);
    //renderer.clearDepth(); // TODO: not sure if we still need this with normalized depth
    renderer.render(scene, camera);
  }
  if (toggle_layer2) {
    setVisibilityForLayerMeshes(0, false);
    setVisibilityForLayerMeshes(1, false);
    setVisibilityForLayerMeshes(2, true);
    //renderer.clearDepth(); // TODO: not sure if we still need this with normalized depth
    renderer.render(scene, camera);
  }

  // In a final pass, render the interface.
  world_group.visible = false;
  interface_group.visible = true;
  renderer.render(scene, camera);  // clears depth automatically (unwanted but unavoidable without warnings from THREE.js and hack workarounds).

  // Reset the view center if we started a VR session 1 frame earlier (we have to wait 1
  // frame to get correct data).
  if (delay1frame_reset) { resetVRToCenter(); }
}



function animate() {
  renderer.setAnimationLoop( render );
}

function initVrController(vr_controller) {
  debugLog("initVrController for controller: " + vr_controller);
  if (!vr_controller) {
    debugLog("initVrController: no controller found");
    return;
  }

  // This is used to prevent the same button press from being handled multiple times.
  vr_controller.lockout_timer = 0;

  vr_controller.addEventListener('select', handleGenericButtonPress);

  vr_controller.addEventListener('connected', function(e) {
    vr_controller.gamepad = e.data.gamepad;
  });

  vr_controller.button_A = false;
  vr_controller.button_B = false;
}





//https://www.w3.org/TR/2016/CR-orientation-event-20160818/#worked-example-2
function getRotationMatrix( alpha, beta, gamma ) {
  var degtorad = Math.PI / 180; // Degree-to-Radian conversion

  var _x = beta  ? beta  * degtorad : 0; // beta value
  var _y = gamma ? gamma * degtorad : 0; // gamma value
  var _z = alpha ? alpha * degtorad : 0; // alpha value

  var cX = Math.cos( _x );
  var cY = Math.cos( _y );
  var cZ = Math.cos( _z );
  var sX = Math.sin( _x );
  var sY = Math.sin( _y );
  var sZ = Math.sin( _z );

  var m11 = cZ * cY - sZ * sX * sY;
  var m12 = - cX * sZ;
  var m13 = cY * sZ * sX + cZ * sY;

  var m21 = cY * sZ + cZ * sX * sY;
  var m22 = cZ * cX;
  var m23 = sZ * sY - cZ * cY * sX;

  var m31 = - cX * sY;
  var m32 = sX;
  var m33 = cX * cY;

  return [
    m11,    m12,    m13,
    m21,    m22,    m23,
    m31,    m32,    m33
  ];
};

function applyHandMaterialRecursive(object, material) {
  object.traverse((child) => {
    if (child.isMesh) {
      child.material = material;
      child.renderOrder = 10; // HACK: draw hands last for transparency without writing to depth
    }
  });
}



function loadTexture(_media_urls, _loop, _autoplay_muted) {
  console.log("Loading texture from media urls: " + _media_urls);
  if (texture) {
    console.log("Deallocating texture " + texture);
    texture.dispose(); // Not clear if this helps or hurst as far as WebGL: context lost errors
    texture = null;
  }
  if (media_mesh && media_mesh.uniforms.uTexture) {
    media_mesh.uniforms.uTexture = null;
  }
  if (video) {
    // Delete the video sources to prevent a memory leak
    while(video.firstChild) {
      console.log("removing source", video.firstChild);
      video.removeChild(video.firstChild);
    }
    video.remove();
    video = null;
  }

  // Create a new <video> element
  var ext = filenameExtension(_media_urls[0]);
  if (ext == "png" || ext == "jpg") {
    photo_mode = true;
    texture = new THREE.TextureLoader().load(
      _media_urls[0],
      function(texture) {// onLoad callback
        is_buffering_at = false;
        if (!transition_start_timer) {
          startAnimatedTransitionEffect();
        }
      },
      function(xhr) { // Progress callback
        //const percentage = (xhr.loaded / xhr.total) * 100;
      },
      function(error) { // error callback
        error_message_div.innerHTML = "Error loading texture: "  + _media_urls[0];
      }
    );
    // Some of this isn't necessary, but makes the texture consistent between Photo/Video.
    texture.format = THREE.RGBAFormat;
    texture.type = THREE.UnsignedByteType;
    texture.minFilter = THREE.LinearFilter; // This matters! Fixes a rendering glitch.
    texture.magFilter = THREE.LinearFilter;
    texture.generateMipmaps = false;
  } else {
    is_buffering_at = performance.now();
    photo_mode = false;
    video = document.createElement('video');
    video.setAttribute("crossorigin", "anonymous");
    video.setAttribute("playsinline", true);
    video.loop = _loop;
    video.style.display = "none";
    video.preload = "auto";
    video.addEventListener("waiting", function() {
      is_buffering_at = performance.now();
    });
    video.addEventListener("playing", function() {
      if (!transition_start_timer) {
        startAnimatedTransitionEffect();
      }
      is_buffering_at = false;
    });
    video.addEventListener("canplay", function() {
      if (!transition_start_timer) {
        startAnimatedTransitionEffect();
      }
      is_buffering_at = false;
    });

    document.body.appendChild(video);

    // Create a <source> for each item in _media_urls
    for (let i = 0; i < _media_urls.length; i++) {
      let source = document.createElement('source');
      source.src = _media_urls[i];
      video.appendChild(source);
    }

    video.addEventListener("error", function() {
      error_message_div.innerHTML = "Failed to load videos: " + _media_urls;
    });

    if (_autoplay_muted) {
      video.muted = true;
      video.play().catch(e => {
        console.error("Error attempting to play video:", e.message);
      });
    }

    texture = new THREE.VideoTexture(video)
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.format = THREE.RGBAFormat;
    texture.type = THREE.UnsignedByteType;
  }
  if (media_mesh) {
    media_mesh.uniforms.uTexture = texture;
  }
  if (media_mesh && format == "ldi3") {
    media_mesh.ldi3_layer0_material.uniforms.uTexture.value = texture;
    media_mesh.ldi3_layer1_material.uniforms.uTexture.value = texture;
    media_mesh.ldi3_layer2_material.uniforms.uTexture.value = texture;

    media_mesh.uniforms.uTexture.value.format = THREE.RGBAFormat;
    media_mesh.uniforms.uTexture.value.type = THREE.UnsignedByteType;
    media_mesh.uniforms.uTexture.value.minFilter = THREE.LinearFilter;
    media_mesh.uniforms.uTexture.value.magFilter = THREE.LinearFilter;
    media_mesh.uniforms.uTexture.value.generateMipmaps = false;

    media_mesh.ldi3_layer0_material.needsUpdate = true;
    media_mesh.ldi3_layer1_material.needsUpdate = true;
    media_mesh.ldi3_layer2_material.needsUpdate = true;
  }
}

function loadMedia(_media_urls, _loop = true, _autoplay_muted = true, _enable_intro_animation = true) {
  loadTexture(_media_urls, _loop, _autoplay_muted);
  if (_enable_intro_animation) {
    startAnimatedTransitionEffect();
  }
}

function init({
  _format = "ldi3", // ldi3, vr180
  _media_urls = [],  // Array in order of preference (highest-quality first)
  _embed_in_div = "",
  _cam_mode="orbit",
  _vfov = 80,
  _min_fov = null,
  _ftheta_scale = null,
  _lock_position = false,
  _decode_12bit = true,
  _looking_glass_config = null,
  _enable_intro_animation = true,
  _autoplay_muted = false, // If this is a video, try to start playing immediately (muting is required)
  _loop = false,
  _transparent_bg = false, //  If you don't need transparency, it is faster to set this to false
 
} = {}) {
  window.lifecast_player = this;

  cam_mode        = _cam_mode;
  lock_position   = _lock_position;
  enable_intro_animation = _enable_intro_animation && (_format != "vr180");

  format = _format;

  looking_glass_config = _looking_glass_config;
  
 

  if (_embed_in_div == "") {
    setBodyStyle();
    container = document.body;
    container.style.margin = "0px";
    container.style.border = "0px";
    container.style.padding = "0px";
  } else {
    embed_mode = true;
    container = byId(_embed_in_div);
  }

  // Remove any existing children of the container (eg. loading spinner)
  while (container.firstChild) {
    container.removeChild(container.firstChild);
  }

  if (new URLSearchParams(window.location.search).get('embed')) {
    embed_mode = true;
  }

  if (cam_mode == "first_person") {
    container.style.cursor = "move";
  }

  error_message_div = document.createElement("div");
  container.appendChild(error_message_div);


  loadTexture(_media_urls, _loop, _autoplay_muted);

  makeNonVrControls();

  let aspect_ratio = window.innerWidth / window.innerHeight;
  if (_min_fov && _vfov * aspect_ratio < _min_fov) {
    // For tall aspect ratios, ensure a minimum FOV
    _vfov = _min_fov / aspect_ratio;
  }
  let z_far = (format == "ldi3") ? 110 : 200;
  camera = new THREE.PerspectiveCamera(_vfov, aspect_ratio, 0.1, z_far);
  if (format == "vr180") {
    camera.layers.enable( 1 );
  }

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  world_group = new THREE.Group();
  interface_group = new THREE.Group();
  scene.add(world_group);
  scene.add(interface_group);

  if (format == "ldi3") {
    media_mesh = new Ldi3Mesh(_decode_12bit, texture, _ftheta_scale)
  } else if (format == "vr180") {
    media_mesh = new Vr180Mesh(texture);
  } else {
    console.error("Unsupported format: " + format);
  }
  world_group.add(media_mesh)

  // Make the point sprite for VR buttons.
  
  if (enable_intro_animation) {
    media_mesh.uniforms.uEffectRadius.value = 0.0;
  }

  // See https://github.com/mrdoob/three.js/blob/dev/examples/webxr_vr_sandbox.html
  // for more examples of using HTMLMesh.
  if (enable_debug_text) {
    debug_text_div = document.createElement("debug_text_div");
    debug_text_div.innerHTML = "";
    debug_text_div.style.width = '400px';
    debug_text_div.style.height = '600px';
    debug_text_div.style.backgroundColor = 'rgba(128, 128, 128, 0.9)';
    debug_text_div.style.fontFamily = 'Arial';
    debug_text_div.style.fontSize = '14px';
    debug_text_div.style.padding = '10px';
    debug_text_div.style.color = 'black';

    // We have to add the div to the document.body or it wont render.
    // But to keep it out of view (in 2D), move it far offscreen.
    debug_text_div.style.position = 'absolute';
    debug_text_div.style.left = '-1000px';
    debug_text_div.style.top = '-1000px';
    document.body.appendChild(debug_text_div);

    debug_text_mesh = new HTMLMesh(debug_text_div);
    debug_text_mesh.position.x = -0.5;
    debug_text_mesh.position.y = 0.25;
    debug_text_mesh.position.z = -1.0;
    debug_text_mesh.rotation.y = Math.PI / 9;
    debug_text_mesh.scale.setScalar(1.0);
    interface_group.add(debug_text_mesh);
  }

  renderer = new THREE.WebGLRenderer({
    antialias: true,
    powerPreference: "high-performance",
    preserveDrawingBuffer: true,
    alpha: _transparent_bg
  });
  renderer.autoClear = false;
  renderer.autoClearColor = false;
  renderer.autoClearDepth = true;
  renderer.autoClearStencil = false;
  renderer.setPixelRatio(window.devicePixelRatio);

  if (_transparent_bg) {
    renderer.setClearColor(0xffffff, 0.0);
    scene.background = null;
  }
  if (_format == "vr180") {
    // VR180 should render fine
  }
 

  //renderer.outputColorSpace = THREE.sRGBEncoding; // TODO: I dont know if this is correct or even does anything. TODO: check Vision Pro
  container.appendChild(renderer.domElement);
  window.addEventListener('resize', onWindowResize);

  if (embed_mode) {
    onWindowResize();
  } else {
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  container.style.position = 'relative';
  

  // Non_VR mouse camera controls.
  if (!is_ios) {
    container.addEventListener('mousemove', function(e) {
      var rect = container.getBoundingClientRect();
      prev_mouse_u = ((e.clientX - rect.left) / rect.width) - 0.5;
      prev_mouse_v = ((e.clientY - rect.top) / rect.height) - 0.5;

      mouse_last_moved_time = Date.now();
    });
  }

  if (cam_mode == "orbit" && !is_ios) {
    orbit_controls = new OrbitControls(camera, renderer.domElement);
    orbit_controls.panSpeed = 0.25;
    orbit_controls.rotateSpeed = 0.1;
    orbit_controls.zoomSpeed = 0.05;
    orbit_controls.target.set(0, 0, -1.0); // NOTE the 2 here is half the octree size of 4 meters^3
    orbit_controls.enableDamping = true;
    orbit_controls.enableZoom = true; // TODO: this is cool but needs some tweaking
    orbit_controls.dampingFactor = 0.3;
    orbit_controls.saveState();
    camera.position.set(0, 0, 0.0);
  }

  if (is_ios && !embed_mode) {
    document.body.style["touch-action"] = "none";
    document.addEventListener('touchmove', function(e) {
      e.preventDefault();
      var touch = e.touches[0];

      let u = (touch.pageX / window.innerWidth - 0.5) * 2.0;
      let v = (touch.pageY / window.innerHeight - 0.5) * 2.0;
      mobile_drag_u = mobile_drag_u * 0.8 + u * 0.2;
      mobile_drag_v = mobile_drag_v * 0.8 + v * 0.2;
    }, false);
  }



  // Disable right click on play/pause button
  const images = document.getElementsByTagName('img');
  for (let i = 0; i < images.length; i++) {
    images[i].addEventListener('contextmenu', event => event.preventDefault());
  }
  container.addEventListener('contextmenu', event => event.preventDefault());
  if (!photo_mode) {
    nonvr_controls.addEventListener('contextmenu', event => event.preventDefault());
    trackMouseStatus(nonvr_controls);

    // Setup button handles for non-VR interface
    byId("play_button").addEventListener('click', handleNonVrPlayButton);
    byId("rewind_button").addEventListener('click', handleNonVrPlayButton);
    byId("pause_button").addEventListener('click', handleNonVrPauseButton);
    byId("buffering_button").addEventListener('click', function() {
      is_buffering_at = false;
      handleNonVrPauseButton();
    });

    document.addEventListener('mousemove', e => {
      if (!mouse_is_down) nonvr_menu_fade_counter = Math.min(60, nonvr_menu_fade_counter + 5);
    });
  }

  document.addEventListener('mousedown', e => {
    mouse_is_down = true;
    if (e.button == 2) right_mouse_is_down = true;
  });
  document.addEventListener('mouseup', e => {
    mouse_is_down = false;
    if (e.button == 2) right_mouse_is_down = false;
  });
  document.addEventListener('mousemove', e => {
    if(right_mouse_is_down) {
      cam_drag_u -= event.movementX / 2000.0;
      cam_drag_v += event.movementY / 2000.0;
    }
  });

  document.addEventListener('keydown', function(event) {
    const key = event.key;
    if (key == " ") {
      toggleVideoPlayPause();
    }
    if (_format == "ldi3") {
      if (key == "z") { toggle_layer0 = !toggle_layer0; }
      if (key == "x") { toggle_layer1 = !toggle_layer1; }
      if (key == "c") { toggle_layer2 = !toggle_layer2; }
    }

    if (key == "a") startAnimatedTransitionEffect();

  });

  renderer.domElement.addEventListener('wheel', function(event) {
    event.preventDefault();
    const MIN_FOV = 30;
    const MAX_FOV = 120;
    // Note: event.deltaY is typically +100 or -100 per wheel click
    const FOV_CHANGE_SPEED = 0.01;
    camera.fov += event.deltaY * FOV_CHANGE_SPEED;
    camera.fov = Math.max(MIN_FOV, Math.min(camera.fov, MAX_FOV));
    camera.updateProjectionMatrix();
  }, false);

  if (is_ios) { // TODO: or android?

    window.addEventListener('orientationchange', function() {
      // reset the "home" angle
      got_orientation_data = false;
    });

    addEventListener('deviceorientation', function(e) {
      // if we got device orientation data, it means we don't need to request it
      if (get_vr_button) {
        get_vr_button.style.display = "none";
      }

      let R = getRotationMatrix(e.alpha, e.beta, e.gamma);
      //console.log("\n" +
      //  R[0].toFixed(2) + " " + R[1].toFixed(2) + " " + R[2].toFixed(2) + "\n" +
      //  R[3].toFixed(2) + " " + R[4].toFixed(2) + " " + R[5].toFixed(2) + "\n" +
      //  R[6].toFixed(2) + " " + R[7].toFixed(2) + " " + R[8].toFixed(2)
      //);
      // Note, below we use the values R[2] and R[8] to determine the motion of the camera
      // in response to the mobile device orientation. Why elements 2 and 8? Answer:
      // trial and error. Intuition: dot products between basis vector and rows or columns
      // of the rotation matrix.
      if (!got_orientation_data) {
        got_orientation_data = true;

        init_orientation_a = R[2];
        init_orientation_b = R[8];
      }

      // Gradually decay the "initial" angle toward whatever the current angle is.
      // This gives it a chance to eventually recover if it gets crooked.
      init_orientation_a = init_orientation_a * 0.995 + R[2] * 0.005;
      init_orientation_b = init_orientation_b * 0.995 + R[8] * 0.005;

      let diff_orientation_a = init_orientation_a - R[2];
      let diff_orientation_b = init_orientation_b - R[8];

      let p = -diff_orientation_b + mobile_drag_v;
      let q = diff_orientation_a + mobile_drag_u;

      camera.fov = _vfov;
      camera.updateProjectionMatrix();

      camera.position.set(-q * 1.0, p * 1.0, 0.0);
      camera.lookAt(0, 0, -1);
    });


  }

  container.addEventListener('mousedown', function() {
    maybe_click = true;
    setTimeout(function() { maybe_click = false; }, 200);
  });
  container.addEventListener('mouseup', function() {
    if (maybe_click) {
      playVideoIfReady();
    }
  });

  // If the Oculus button is held to reset the view center, we need to move the
  // world_group back to 0.
  var reset_event_handler = function(event) {
    world_group.position.set(0, 0, 0);
    gesture_control.reset();
  };

  

  // Remove any redundant loading indicator (from LifecastVideoPlayerPreloader)
  let preload_indicators = container.getElementsByClassName("lifecast_preload_indicator");
  for (let i = 0; i < preload_indicators.length; i++) {
    preload_indicators[i].style.display = "none";
  }

  animate();
} // end init()


/////////////////////////////////////////////
/////////////////////////////////////////////
/////////////////////////////////////////////
// Main Part
import * as THREE from 'three';
import {OrbitControls} from "https://cdn.jsdelivr.net/npm/three@0.152.0/examples/jsm/controls/OrbitControls.js";

init({
  _media_urls: [
   "facepaint_ldi3_h264_1920x1920.mp4",
  ],
  //_embed_in_div: "",
  //_cam_mode: "orbit", // orbit, first_person
  //_vfov: 80,  // vertical field of view
  //_min_fov: 60,  // field of view will scale up such that the lesser of hfov and vfov is this value
  //_lock_position: false, // If true, do not allow camera motion
  //_enable_intro_animation: true, // Displays a 8-second animation on load
  _autoplay_muted: true, // If this is a video, try to start playing immediately (muting is required)
  _loop: true,  // If true, loop video
  _transparent_bg: true //  If you don't need transparency, it is faster to set this to false
});